[{"title":"借助GitHub搭建属于自己的maven仓库教程","slug":"借助GitHub搭建属于自己的maven仓库教程","date":"2018-02-12T06:01:13.000Z","updated":"2018-02-13T03:21:17.019Z","comments":true,"path":"2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","link":"","permalink":"https://zbang.online/hexblog/2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","excerpt":"","text":"I. 背景在Github上也写了不少的项目了，然后经常遇到的一个问题就是，很多自己写的项目，希望在另外一个项目中使用时，只能把这个项目下载下来，相当之不方便 因为大多数的java后端项目都是基于maven管理依赖的，所以就希望能有一个公共的maven仓库，可以把自己的项目扔进去，然后再应用就方便很多了 基于此，就有了本文这个教程了 II. 实现步骤1. github仓库建立新建一个repository的前提是有github帐号，默认看到本文的是有帐号的 首先是在github上新建一个仓库，命令随意，如我新建项目为 https://github.com/liuyueyi/maven-repository 2. 配置本地仓库本地指定一个目录，新建文件夹 maven-repository, 如我的本地配置如下 1234567891011121314## 进入目录cd /Users/yihui/GitHub## 新建目录mkdir maven-repository; cd maven-repository## 新建repository目录# 这个目录下面就是存放我们deploy的项目相关信息# 也就是说我们项目deploy指定的目录，就是这里mkdir repository## 新增一个readme文档# 保持良好的习惯，每个项目都有一个说明文档touch README.md 这个目录结构为什么是这样的？ 我们直接看maven配置中默认的目录结构，同样拷贝一份出来而已 3. 仓库关联将本地的仓库和远程的github仓库关联起来，执行的命令也比较简单了 1234git add .git commit -m 'first comit'git remote add origin https://github.com/liuyueyi/maven-repository.gitgit push -u origin master 接着就是进行分支管理了 约定将项目中的snapshot版，deploy到仓库的 snapshot分支上 约定将项目中的release版，deploy到仓库的 release分支上 master分支管理所有的版本 所以需要新创建两个分支 12345678## 创建snapshot分支git checkout -b snapshot git push origin snapshot# 也可以使用 git branch snapshot , 我通常用上面哪个，创建并切换分支## 创建release分支git checkout -b releasegit push origin release 4. 项目deploy项目的deploy，就需要主动的指定一下deploy的地址了，所以我们的deploy命令如下 12## deploy项目到本地仓库mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository 上面的命令就比较常见了，主要需要注意的是file后面的参数，根据自己前面设置的本地仓库目录来进行替换 5. deploy脚本每次进行上面一大串的命令，不太好记，特别是不同的版本deploy到不同的分支上，主动去切换分支并上传，也挺麻烦，所以就有必要写一个deploy的脚本了 由于shell实在是不太会写，所以下面的脚本只能以凑合能用来说了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashif [ $# != 1 ];then echo 'deploy argument [snapshot(s for short) | release(r for short) ] needed!' exit 0fi## deploy参数，snapshot 表示快照包，简写为s， release表示正式包，简写为rarg=$1DEPLOY_PATH=/Users/yihui/GitHub/maven-repository/CURRENT_PATH=`pwd`deployFunc()&#123; br=$1 ## 快照包发布 cd $DEPLOY_PATH ## 切换对应分支 git checkout $br cd $CURRENT_PATH # 开始deploy mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository # deploy 完成,提交 cd $DEPLOY_PATH git add -am 'deploy' git push origin $br # 合并master分支 git checkout master git merge $br git commit -am 'merge' git push origin master cd $CURRENT_PATH&#125;if [ $arg = 'snapshot' ] || [ $arg = 's' ];then ## 快照包发布 deployFunc snapshotelif [ $arg = 'release' ] || [ $arg = 'r' ];then ## 正式包发布 deployFunc releaseelse echo 'argument should be snapshot(s for short) or release(r for short). like: `sh deploy.sh snapshot` or `sh deploy.sh s`'fi 将上面的脚本，考本到项目的根目录下，然后执行 12345678chmod +x deploy.sh## 发布快照包./deploy.sh s# sh deploy.sh snapshot 也可以## 发布正式包./deploy.sh r 基于此，整个步骤完成 III. 使用上面仓库的基本搭建算是ok了，然后就是使用了，maven的pom文件应该怎么配置呢？ 首先是添加仓库地址 添加仓库 如果要区分snapshot和release的话，如下配置 12345678910&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-snap&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/snapshot/repository&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-release&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/release/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 如果不care的话，直接添加下面的即可 123456&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/master/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 仓库配置完毕之后，直接引入依赖即可，如依赖我的Quick-Alarm包，就可以添加下面的依赖配置 12345&lt;dependency&gt; &lt;groupId&gt;com.hust.hui.alarm&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; IV. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"Git","slug":"Shell/Git","permalink":"https://zbang.online/hexblog/categories/Shell/Git/"},{"name":"Maven","slug":"Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/Shell/Git/Maven/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zbang.online/hexblog/tags/Github/"},{"name":"Maven","slug":"Maven","permalink":"https://zbang.online/hexblog/tags/Maven/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"}],"keywords":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"Git","slug":"Shell/Git","permalink":"https://zbang.online/hexblog/categories/Shell/Git/"},{"name":"Maven","slug":"Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/Shell/Git/Maven/"}]},{"title":"6. 报警系统QuickAlarm使用手册","slug":"报警系统QuickAlarm使用手册","date":"2018-02-11T10:53:33.000Z","updated":"2018-02-13T03:21:17.020Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm使用手册/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm使用手册/","excerpt":"","text":"本文将主要说明QuickAlarm该如何使用，以及使用时需要注意事项 1. 基本使用姿势首先我们不做任何的自定义操作，全部依靠系统默认的实现，我们的使用步骤如下 1. 添加注册文件首先在项目的资源目录下，添加注册文件 alarm.properties，文件内容如下 12345678910111213## 应用名，必填appName=test## 报警规则文件所在的路径，如果采用系统默认加载方式，必填## / 开头，表示存的是绝对路径## 非/开头，表示存的是系统相对路径，一般是放在资源目录下alarmConfPath=/tmp/alarmConfig## 最大的报警类型，非必填maxAlarmType=1000## 默认报警用户，必填defaultAlarmUsers=yihui 具体存放的位置，可以参考下图，放在resources目录下（源码中，是放在测试资源目录下的） 2. 添加报警规则根据注册文件中指定的路径，设置报警规则文件，如我们的报警规则文件 内容为json串格式，支持格式化的json串解析，为了节省篇幅，下面压缩成一行，点击获取json格式化小工具 /tmp/alarmConig: 1&#123;\"default\":&#123;\"level\":\"LOG\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"LOG\",\"threshold\":5,\"users\":[\"yihui\",\"erhui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"NPE\":&#123;\"level\":\"WEIXIN\",\"autoIncEmergency\":false,\"max\":30,\"min\":0,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"3h ui\",\"4hui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"XXX,YYY\":&#123;\"level\":\"EMAIL\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"EMAIL\",\"threshold\":5,\"users\":[\"yihui@xxx.com\",\"erhui@xxx.com\"]&#125;],\"users\":[\"yihui@xxx.com\"]&#125;&#125; 3. 测试类一个简单的使用测试 123456789101112@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; II. 报警执行机器扩展前面的报警规则配置中，有WEIXIN, SMS, EMAIL的报警，但是系统只提供了两个NONE和LOG，所以我们可以看下如何自定义实现上面的三个 1. 实现IExecute接口邮件报警 123456public class EmailExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 短信报警 12345678910/** * Created by yihui on 2018/2/7. */public class SmsExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 微信报警 123456789/** * Created by yihui on 2018/2/7. */public class WeiXinExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 说明，因为没有具体的实现，所以我们直接用日志输出来模拟，所以就都继承了LogExecute, 实际使用中，可以在上面补上相应的实现代码 2. 添加SPI定义在 resources 目录下，新增 目录：META-INF/services/ 文件：com.hust.hui.alarm.core.execut.api.IExecute 文件内容为上面几个实现类的全路径 123com.hust.hui.alarm.core.test.execute.EmailExecutecom.hust.hui.alarm.core.test.execute.SmsExecutecom.hust.hui.alarm.core.test.execute.WeiXinExecute 目录结构如： 3. 测试1234567891011121314151617181920public static void main(String[] args) throws InterruptedException &#123; // 测试异常升级的case // 计数 [1 - 2] 默认报警（即无日志） （其中 &lt; 3 的是因为未达到下限, 采用的默认报警） // 计数 [3 - 4] 默认邮件报警（其中 &lt; 5 采用的默认报警, 与下面的区别是报警用户） // 计数 [5 - 9] 邮件报警 （大于5小于10根据上升规则,还是选择邮件报警） // 计数 [10 - 19] 微信报警 // 计数 [20 - 30] 短信报警 // 计数 [31 -] 默认报警 （超过上限, 不报警） for (int i = 0; i &lt; 40; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; AlarmWrapper.getInstance().sendMsg(\"YYY\", \"异常报警升级测试\"); &#125; &#125;).start(); &#125; Thread.sleep(1000 * 600);&#125; 实测输出结果如下: 1234567891011121314151617181920212223242526272818:36:28.997 [Thread-12] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 26 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-24] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 16 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-33] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 6 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-22] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 18 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-26] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-23] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 17 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-35] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 4 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-3] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 5 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-18] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 27 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-11] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 28 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-21] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 19 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-2] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 9 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-14] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 24 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-10] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 29 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-15] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 22 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-16] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 23 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 15 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-9] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 30 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-13] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 25 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-19] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 21 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-34] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 3 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-4] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 7 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:36:29.011 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-5] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 8 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-1] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 20 &gt;&gt;&gt; 异常报警升级测试 III. 报警规则加载自定义1. 实现IConfLoader接口自定义加载器，给了一个最基本的 12345678910111213141516171819202122232425262728293031323334public class SelfAlarmConfLoader implements IConfLoader &#123; @Override public RegisterInfo getRegisterInfo() &#123; RegisterInfo registerInfo = new RegisterInfo(); registerInfo.setMaxAlarmType(100); registerInfo.setDefaultAlarmUsers(\"yihui\"); registerInfo.setAppName(\"test\"); return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public int order() &#123; return 0; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; //db 查询，获取对应的配置信息 // 下面是模拟，返回一个固定的配置 AlarmConfig alarmConfig = new AlarmConfig(); alarmConfig.setAlarmLevel(\"WEIXIN\"); alarmConfig.setAutoIncEmergency(false); alarmConfig.setMinLimit(10); alarmConfig.setMaxLimit(14); alarmConfig.setUsers(Arrays.asList(\"yihui\")); alarmConfig.setAlarmThreshold(Collections.emptyList()); return alarmConfig; &#125;&#125; 2. 添加SPI配置在resources目录下新增 目录： META-INF/services 文件： com.hust.hui.alarm.core.loader.api.IConfLoader 文件内容 1com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader 3. 测试同样是上面的代码，输出结果 1234518:43:04.275 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:43:04.276 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试 4. 说明系统默认的order是10，所以如果在测试上面的第二步时，不妨把com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader#order返回值，改成大于10，这样就会走到默认的配置加载类 采用 SelfAlarmConfLoader 时，前面说的两个基础配置文件，是可以没有的，完全不会有任何影响，因为对应的注册类和报警规则，都是右这个类内部提供了 IV. 小结所有测试相关数据，均可以在测试工程中获取，请主要关注: 测试case 注册文件：alarmConfig 报警规则配置文件：alarm.properties V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}]},{"title":"5. 报警系统QuickAlarm之频率统计及接口封装","slug":"报警系统QuickAlarm之频率统计及接口封装","date":"2018-02-11T08:59:47.000Z","updated":"2018-02-13T03:21:17.020Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","excerpt":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦","text":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦 I. 报警频率统计1. 设计前面在解析报警规则时，就有一个count参数，用来确定具体选择什么报警执行器的核心参数，我们维护的方法也比较简单： 针对报警类型，进行计数统计，没调用一次，则计数+1 每分钟清零一次 2. 实现因为每种报警类型，都维护一个独立的计数器 定义一个map来存储对应关系 1private ConcurrentHashMap&lt;String, AtomicInteger&gt; alarmCountMap; 每分钟执行一次清零 1234567// 每分钟清零一把报警计数ScheduledExecutorService scheduleExecutorService = Executors.newScheduledThreadPool(1);scheduleExecutorService.scheduleAtFixedRate(() -&gt; &#123; for (Map.Entry&lt;String, AtomicInteger&gt; entry : alarmCountMap.entrySet()) &#123; entry.getValue().set(0); &#125;&#125;, 0, 1, TimeUnit.MINUTES); 注意上面的实现，就有什么问题？ 有没有可能因为map中的数据过大（或者gc什么原因），导致每次清零花不少的时间，而导致计数不准呢？ （先不给出回答） 计数加1操作 1234567891011121314151617/** * 线程安全的获取报警总数 并自动加1 * * @param key * @return */private int getAlarmCount(String key) &#123; if (!alarmCountMap.containsKey(key)) &#123; synchronized (this) &#123; if (!alarmCountMap.containsKey(key)) &#123; alarmCountMap.put(key, new AtomicInteger(0)); &#125; &#125; &#125; return alarmCountMap.get(key).addAndGet(1);&#125; II. 报警线程池目前也只是提供了一个非常简单的线程池实现，后面的考虑是抽象一个基于forkjoin的并发框架来处理（主要是最近接触到一个大神基于forkjoin写的并发器组件挺厉害的，所以等我研究透了，山寨一个） 123456// 报警线程池private ExecutorService alarmExecutorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10), new DefaultThreadFactory(\"sms-sender\"), new ThreadPoolExecutor.CallerRunsPolicy()); 任务提交执行 12345678private void doSend(final ExecuteHelper executeHelper, final AlarmContent alarmContent) &#123; alarmExecutorService.execute(() -&gt; executeHelper.getIExecute().sendMsg( executeHelper.getUsers(), alarmContent.getTitle(), alarmContent.getContent()));&#125; III. 接口封装这个就没什么好说的了 123456789101112131415161718192021222324252627282930313233343536373839404142public void sendMsg(String key, String content) &#123; sendMsg(new AlarmContent(key, null, content));&#125;public void sendMsg(String key, String title, String content) &#123; sendMsg(new AlarmContent(key, title, content));&#125;/** * 1. 获取报警的配置项 * 2. 获取当前报警的次数 * 3. 选择适当的报警类型 * 4. 执行报警 * 5. 报警次数+1 * * @param alarmContent */private void sendMsg(AlarmContent alarmContent) &#123; try &#123; // get alarm config AlarmConfig alarmConfig = confLoader.getAlarmConfig(alarmContent.key); // get alarm count int count = getAlarmCount(alarmContent.key); alarmContent.setCount(count); ExecuteHelper executeHelper; if (confLoader.alarmEnable()) &#123; // get alarm execute executeHelper = AlarmExecuteSelector.getExecute(alarmConfig, count); &#125; else &#123; // 报警关闭, 则走空报警流程, 将报警信息写入日志文件 executeHelper = AlarmExecuteSelector.getDefaultExecute(); &#125; // do send msg doSend(executeHelper, alarmContent); &#125; catch (Exception e) &#123; logger.error(\"AlarmWrapper.sendMsg error! content:&#123;&#125;, e:&#123;&#125;\", alarmContent, e); &#125;&#125; 接口封装完毕之后如何使用呢？ 我们使用单例模式封装了唯一对外使用的类AlarmWrapper，使用起来也比较简单，下面就是一个测试case 12345678910111213@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; 使用起来比较简单，就那么一行即可，从这个使用也可以知道，整个初始化，就是在这个对象首次被访问时进行 构造函数内容如下: 12345678910private AlarmWrapper() &#123; // 记录每种异常的报警数 alarmCountMap = new ConcurrentHashMap&lt;&gt;(); // 加载报警配置信息 confLoader = ConfLoaderFactory.loader(); // 初始化线程池 initExecutorService();&#125; 所有如果你希望在自己的应用使用之前就加载好所有的配置，不妨提前执行一下 AlarmWrapper.getInstance() IV. 小结基于此，整个系统设计基本上完成，当然代码层面也ok了，剩下的就是使用手册了 再看一下我们的整个逻辑，基本上就是下面这个流程了 提交报警 封装报警内容（报警类型，报警主题，报警内容） 维护报警计数（每分钟计数清零，每个报警类型对应一个报警计数） 选择报警 根据报警类型选择报警规则 根据报警规则，和当前报警频率选择报警执行器 若不开启区间映射，则返回默认执行器 否则遍历所有执行器的报警频率区间，选择匹配的报警规则 执行报警 封装报警任务，提交线程池 报警执行器内部实现具体报警逻辑 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}]},{"title":"4. 报警系统QuickAlarm之报警规则解析","slug":"报警系统QuickAlarm之报警规则解析","date":"2018-02-11T08:08:04.000Z","updated":"2018-02-13T03:21:17.020Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之报警规则解析/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之报警规则解析/","excerpt":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器","text":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器 I. 背景知识点0. 声明在正式进入之前，有必要额外声明一下，因为目前的v1版本，没有开放报警规则的自定义，也就是说，目前只支持默认的报警规则，所以接下来的主要内容将集中在 系统默认的报警规则的解析 即基于报警频率阀值，自动选择报警执行器的规则解析 1. 报警规则如果对于报警规则，依然不是很清晰的，可以阅读一下《报警系统QuickAlarm之报警规则的设定与加载》 这里简单的进行说明，系统中默认的报警规则结构为： key为报警类型（即用户执行报警时，传进来的报警类型参数） value为具体报警规则 每个报警执行器拥有一个报警频率区间，通过报警频率映射到报警执行器的区间来选择对应的AlarmExecutor，这就是系统定义的报警规则 II. 报警规则解析通过前面的报警规则的简单说明，基本上也可以捞出报警规则的解析原则了 每种报警类型，对应一个报警规则 每个报警规则中，可以有多个报警执行器 每个报警执行器都有一个对应的报警频率的阀值 根据阀值对所有的报警执行器排序 计算报警频率，映射到哪个区间，则选择哪个报警执行器 上面是一个简单的解析规则，当然实际上和这个差不多，但有一些问题需要额外注意 只想选择一种报警方式，是否可以支持？ 多重报警方式同时调用怎么处理？（如我希望用短信提示说有问题，同时用邮件包含详细的异常堆栈） 频率限制 报警类型没有设置报警规则如何处理？ 报警规则中使用了一个未注册的报警执行器会怎样？ 1. 实现方案说明再次将报警规则类拿出来看一下 12345678910111213141516171819202122232425262728293031323334/** * 报警用户 */private List&lt;String&gt; users;/** * 报警的阀值 */private List&lt;AlarmThreshold&gt; alarmThreshold;/** * 最小的报警数 */private int minLimit;/** * 最大的报警数 */private int maxLimit;/** * 报警类型 &#123;@link IExecute#getName()&#125; */private String alarmLevel;/** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */private boolean autoIncEmergency; 针对上面的问题，逐一说明 首先是 autoIncEmergency 这个参数，如果为true，则表示可以走上面的哪个区间映射的规则；否则就全部走AlarmConfig中默认的报警类型了 minLimit : 表示发生报警的频率下限值，小于这个值就不会执行具体的报警逻辑 maxLimit : 最大的报警频率，超过了也不报警（简单的频率控制） alarmLevel: 对应的就是具体的报警类型 alarmThreshold: 这个只有在autoIncEmergency=true时，才有小，也就是我们前面说的不同的报警执行器，根据阀值区间进行排序，开启之后，遍历，判断频率是否在这个区间内，若在，则表示可以选择它了 如果不存在报警规则，则采用默认的兜底规则 若报警执行器也不存在，就直接采用系统定义的日志报警执行器 2. 实现基本上前面已经将整个逻辑都说了，所以实际的编码反而比较清晰了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 获取具体的报警执行器 * &lt;p&gt; * 1. 未开启严重等级上升时, 直接返回 * 2. 开启之后, 判断当前的计数 范围 * * @param alarmConfig 报警配置项, 内部所有的参数都不可能为null */public static ExecuteHelper getExecute(final AlarmConfig alarmConfig, int count) &#123; // 未达到报警的下限 or 超过报警的上限时 if (count &lt; alarmConfig.getMinLimit() || count &gt; alarmConfig.getMaxLimit()) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers()); &#125; // 未开启报警升级, 直接返回 if (!alarmConfig.isAutoIncEmergency()) &#123; return new ExecuteHelper(SimpleExecuteFactory. getExecute(alarmConfig.getAlarmLevel()), alarmConfig.getUsers()); &#125; // 报警等级开启上升之趋势 // 1. 获取设置的默认等级 // 2. 判断当前的报警次数, 选择对应的报警类型 // 3. 选择具体的报警类型 String defaultLevel = alarmConfig.getAlarmLevel(); String selectLevel = null; List&lt;String&gt; selectUser = alarmConfig.getUsers(); List&lt;AlarmThreshold&gt; list = alarmConfig.getAlarmThreshold(); boolean useNew = false; boolean containDefaultLevel = false; for (AlarmThreshold alarmThreshold : list) &#123; if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; containDefaultLevel = true; &#125; &#125; for (AlarmThreshold alarmThreshold : list) &#123; // 表示当前的报警等级已经赶上默认的报警等级了, 所以要选择新的报警类型 if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; useNew = true; &#125; if (count &lt; alarmThreshold.getThreshold()) &#123; break; &#125; selectLevel = alarmThreshold.getAlarmLevel(); // 选择新的报警类型时, 需要更新报警用户 selectUser = alarmThreshold.getUsers(); &#125; // 阀值列表中不包含默认报警类型，则根据新的来 if (!containDefaultLevel &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; // 如果阀值列表中包含了默认报警类型, 且已经超过默认阀值 if (useNew &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; else &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(defaultLevel), alarmConfig.getUsers()); &#125;&#125; 具体的实现基本和我们前面分析的一样，但有一个地方需要额外注意 默认报警阀值，可以直接决定是否需要报警 因此定义的其他报警方式的阀值，应该在默认的阀值区间内 当然AlarmThreshold中不包含默认报警方式时，优先选择阀值区间的报警方式 当然AlarmThreshold中包含默认报警方式时，根据新的规则做处理 （吐槽：上面这个实现有点绕，后面想办法规避下，搞得不太好理解了） 另外一个问题就是，上面的实现没有支持可以同时选择多个报警执行器的情况 因为考虑到后面肯定会对报警规则的定义和解析放开，所以先实现了一个简单的场景，具体的放在后面处理 III. 小结到这里报警规则和报警执行器之间的解析关系已确定，剩下的东西就简单了，一个维持报警频率计数，一个报警线程池，再加上一个对外接口的封装而言 基本上，到这里主要的核心逻辑已经完成，小结一下本系统中的核心设计理念 – 一切可自定义（当然目前差得有点远） 1. 报警执行器 通过SPI机制支持用户自定义扩展 要求 Executor 拥有唯一标识 因为报警执行器支持扩展，所以Executor的内部实现，完全可以由用户决定 2. 报警规则 目前报警规则只提供默认的基于频率区间的选择方案 报警规则通过报警执行器的name与之唯一对应，若对应不上，则选择默认执行器 报警规则的加载同样基于SPI，支持自定义，因此报警规则可以存在任何地方 报警规则加载器，提供一个报警规则变动的钩子(load()),若采用自定义的加载类，则确保规则变动时，主动回调这个方法 默认的报警规则加载类，是基于系统的配置文件实现，内部托管了文件的变动更新事件（使用commons-io实现） IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}]},{"title":"3. 报警系统QuickAlarm之报警规则的设定与加载","slug":"报警系统QuickAlarm之报警规则的设定与加载","date":"2018-02-09T11:39:43.000Z","updated":"2018-02-13T03:21:17.020Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","excerpt":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择","text":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择 I. 报警规则定义 目前针对报警规则没有给出自定义配置的入口，即完全采用了默认的方案，后续可以考虑支持适用方来自定义报警规则以及解析器，这样扩展性就更强了 首先说明下我们的设计规则，我们针对不同的AlarmExecute定义了一个优先级，我们的目标是 针对报警频率设置不同区间，每个区间对应一种报警类型 当实际调用的报警频率达到这个区间，就选择这种报警类型 同时也允许关闭根据频率选择报警器的功能，全程用一个默认 每种报警类型的用户都可以自定义 针对上面的目标，我们设计的类就比较明确了 阀值类： 1234567891011121314151617181920212223242526272829303132@Getter@Setter@ToStringpublic class AlarmThreshold implements Comparable&lt;AlarmThreshold&gt; &#123; /** * 报警类型，对应 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * 晋升此报警的阀值 */ private int threshold; /** * 对应的报警用户 */ private List&lt;String&gt; users; @Override public int compareTo(AlarmThreshold o) &#123; if (o == null) &#123; return -1; &#125; return threshold - o.getThreshold(); &#125;&#125; 配置类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Getter@Setter@ToStringpublic class AlarmConfig &#123; public static final int DEFAULT_MIN_NUM = 0; public static final int DEFAULT_MAX_NUM = 30; /** * 报警用户 */ private List&lt;String&gt; users; /** * 报警的阀值 */ private List&lt;AlarmThreshold&gt; alarmThreshold; /** * 最小的报警数 */ private int minLimit; /** * 最大的报警数 */ private int maxLimit; /** * 报警类型 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */ private boolean autoIncEmergency;&#125; 一个报警类型对应一个AlarmConfig，这样当执行报警时，就可以很容易的获取对应的规则 同样根据定义，也可以看出报警规则比较简单，直接根据阀值区间来选择 II. 报警规则加载关于如何加载报警规则，想了很久，选择把这块放开，因为我们无法确定，使用方的配置是存在什么地方的，而且使用的配置是否能和我们的设计的DO兼容也是个问题，因此干脆放手，同样是通过SPI的方式来做的 我们定义规则加载接口： IConfLoader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface IConfLoader &#123; /** * 加载配置到内存的操作，启动时，被调用 * * @return true 表示加载成功; false 表示加载失败 */ default boolean load() &#123; return true; &#125; /** * 排序，越小优先级越高 * &lt;p&gt; * 说明： 当系统中多个Loader存在时，会根据优先级来选择order最小的一个作为默认的Loader * * @return */ default int order() &#123; return 10; &#125; /** * 获取注册信息 * * @return */ RegisterInfo getRegisterInfo(); /** * 是否开启报警 * * @return */ boolean alarmEnable(); /** * 根据报警类型，获取对应的报警规则 * * @param alarmKey * @return */ AlarmConfig getAlarmConfig(String alarmKey);&#125; 上面的方法，可以划分为两类: 加载时使用 load 为具体的执行加载配置到内存的方法，返回true表示加载成功 order 排序 getRegisterInfo 获取基础的配置信息（包括应用名等相关配置） 业务运行时使用 alarmEnable ： 是否开启报警 （当大量报警时，可以先关闭报警，然后再查问题） getAlarmConfig：核心方法，根据报警类型，返回对应的报警规则 系统默认提供一个从配置文件中加载报警规则的方案，主要会依赖两个配置文件 alarm.properties : 初始化注册信息，内部保存 RegisterInfo 所需要的属性 alarmConfig : 保存具体的报警规则，json格式 1. 配置加载配置加载的实现逻辑，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class PropertiesConfLoader implements IConfLoader &#123; private RegisterInfo registerInfo; private Map&lt;String, AlarmConfig&gt; cacheMap; public boolean load() &#123; // 获取注册信息 registerInfo = RegisterInfoLoaderHelper.load(); if (registerInfo == null) &#123; return false; &#125; // 获取报警的配置类 File file; String path = registerInfo.getAlarmConfPath(); if (path.startsWith(\"/\")) &#123; file = new File(path); &#125; else &#123; URL url = this.getClass().getClassLoader().getResource(path); file = new File(url.getFile()); &#125; // 加载成功，才替换 cacheMap的内容； 主要是为了防止修改配置出现问题 Map&lt;String, AlarmConfig&gt; tmp = init(file); boolean ans = tmp != null; // 注册配置文件的变动 ans = ans &amp;&amp; PropertiesConfListenerHelper.registerConfChangeListener(file, this::init); if (ans) &#123; cacheMap = tmp; &#125; return ans; &#125; private Map&lt;String, AlarmConfig&gt; init(File file) &#123; try &#123; // 正常来讲，是一个完整的json串 List&lt;String&gt; list = IOUtils.readLines(new FileInputStream(file), \"utf-8\"); String config = Joiner.on(\"\").join(list); return AlarmConfParse.parseConfig(config, Splitter.on(\",\").splitToList(registerInfo.getDefaultAlarmUsers())); &#125; catch (IOException e) &#123; log.error(\"load config into cacheMap error! e: &#123;&#125;\", e); return null; &#125; &#125; @Override public RegisterInfo getRegisterInfo() &#123; return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; AlarmConfig config = cacheMap.get(alarmKey); if (config == null) &#123; return cacheMap.get(AlarmConfParse.DEFAULT_ALARM_KEY); &#125; else &#123; return config; &#125; &#125;&#125; 主要查看默认的load方法即可, alarmEnable 和 getAlarmConfig还是比较简单的，看一下就知道怎么玩的 2. RegisterInfo 加载上面的实现中，第一步就是从 alarm.properteis 文件中读取对应的配置，然后初始化 RegisterInfo对象 1234567891011@Datapublic class RegisterInfo implements Serializable &#123; // 报警规则文件的路径，系统默认加载时，必填；否则选填 private String alarmConfPath; // 最大报警类型数，非必填，默认1000 private Integer maxAlarmType; // 默认报警用户， 必须 private String defaultAlarmUsers; // 应用名， 必须 private String appName;&#125; 一个配置文件实例 1234appName=testalarmConfPath=/tmp/alarmConfigmaxAlarmType=1000defaultAlarmUsers=yihui 从配置文件中读取信息，然后初始化对象的过程就比较简单了，我这里做了一个小简化，使用反射的方式实现对象拷贝 123456789101112131415161718public static void copy(Properties source, Object dest) throws IllegalAccessException &#123; Field[] fields = dest.getClass().getDeclaredFields(); for (Field f : fields) &#123; // 不修改静态变量 if (Modifier.isStatic(f.getModifiers())) &#123; continue; &#125; f.setAccessible(true); // 值拷贝，因为不同数据类型的问题，所以需要对properties中获取的String类型转换一把 f.set(dest, parseObj(source.getProperty(f.getName()), f.getType())); &#125;&#125;// 强制类型转换private static &lt;T&gt; T parseObj(String obj, Class&lt;T&gt; clz) &#123; return ParseFuncEnum.getFunc(clz).apply(obj);&#125; 上面的实现目前比较简单，没有考虑父类的情况，没有考虑复杂的数据类型转换，目前只支持了基本类型的转换，后续可考虑抽象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public enum ParseFuncEnum &#123; INT_PARSE(Arrays.asList(int.class, Integer.class)) &#123; @Override public Function&lt;String, Integer&gt; getFunc() &#123; return Integer::valueOf; &#125; &#125;, LONG_PARSE(Arrays.asList(long.class, Long.class)) &#123; @Override public Function&lt;String, Long&gt; getFunc() &#123; return Long::valueOf; &#125; &#125;, BOOLEAN_PARSE(Arrays.asList(boolean.class, Boolean.class)) &#123; @Override public Function&lt;String, Boolean&gt; getFunc() &#123; return Boolean::valueOf; &#125; &#125;, FLOAT_PARSE(Arrays.asList(float.class, Float.class)) &#123; @Override public Function&lt;String, Float&gt; getFunc() &#123; return Float::valueOf; &#125; &#125;, DOUBLE_PARSSE(Arrays.asList(double.class, Double.class)) &#123; @Override public Function&lt;String, Double&gt; getFunc() &#123; return Double::valueOf; &#125; &#125;, SHORT_PARSE(Arrays.asList(short.class, Short.class)) &#123; @Override public Function&lt;String, Short&gt; getFunc() &#123; return Short::valueOf; &#125; &#125;, BYTE_PARSE(Arrays.asList(byte.class, Byte.class)) &#123; @Override public Function&lt;String, Byte&gt; getFunc() &#123; return Byte::valueOf; &#125; &#125;, CHAR_PARSE(Arrays.asList(char.class, Character.class)) &#123; @Override public Function&lt;String, Character&gt; getFunc() &#123; return s -&gt; s.charAt(0); &#125; &#125;, STRING_PARSE(Arrays.asList(String.class)) &#123; @Override public Function&lt;String, String&gt; getFunc() &#123; return s -&gt; s; &#125; &#125;,; private List&lt;Class&gt; clzList; public abstract &lt;T&gt; Function&lt;String, T&gt; getFunc(); private static Map&lt;Class, ParseFuncEnum&gt; map = new ConcurrentHashMap&lt;&gt;(20); static &#123; for (ParseFuncEnum enu : ParseFuncEnum.values()) &#123; for (Class clz : enu.clzList) &#123; map.put(clz, enu); &#125; &#125; &#125; ParseFuncEnum(List&lt;Class&gt; clz) &#123; this.clzList = clz; &#125; public static &lt;T&gt; Function&lt;String, T&gt; getFunc(Class&lt;T&gt; clz) &#123; return map.get(clz).getFunc(); &#125;&#125; 3. 报警规则加载注册信息加载完毕之后，就可以获取报警规则的文件地址了，因此首先是读取配置规则的内容（我们要求是JSON格式），然后反序列化即可 将json串格式配置，反序列化为 BaseAlarmConf 对象 12345678910111213141516171819202122232425262728293031323334353637private static final TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt; typeReference = new TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt;() &#123;&#125;;/** * 将json串格式的报警规则配置，映射为对应实体类 * &lt;p&gt; * 如果传如的是null, 则采用默认的兜底配置 * 如果传入的是非法的配置，直接返回null， 这样做的目的如下 * &lt;p&gt; * - 启动时，直接获知配置有问题，需要修改 * - 启动中，修改配置，此时新配置有问题，依然使用旧的配置 * * @param configs * @return */private static Map&lt;String, BasicAlarmConfig&gt; parseStrConfig2Map(String configs) &#123; Map&lt;String, BasicAlarmConfig&gt; map = null; if (configs != null) &#123; try &#123; map = JSON.parseObject(configs, typeReference); &#125; catch (Exception e) &#123; logger.error(\"ConfigWrapper.parseStrConfig2Map() init config error! configs: &#123;&#125;, e:&#123;&#125;\", configs, e); return null; &#125; &#125; if (map == null) &#123; map = new HashMap&lt;&gt;(1); &#125; if (!map.containsKey(DEFAULT_ALARM_KEY)) &#123; map.put(DEFAULT_ALARM_KEY, DEFAULT_ALARM_CONFIG); &#125; return map;&#125; 需要额外说明一下，json串并没有直接的映射我们前面定义的 AlarmConfig 对象，因为在原型版本的设计的过程中，考虑到配置与内部的使用对象，可能不是特别匹配，最初的设计中，是希望直接将AlarmConfig中的alarmLevel直接替换成 AlarmExecute 实例对象的，然而在实际实现中没有这么干…，所以看源码时，这里就有点奇怪，后面完全可以干掉这个无用的逻辑 此外，就是需要给一个默认的配置项，当报警类型匹配不到对应的报警规则时，就选择默认的了 下面是一个报警配置的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#123; \"default\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE\": &#123; \"level\": \"WEIXIN\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"3h ui\", \"4hui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"XXX,YYY\": &#123; \"level\": \"EMAIL\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"EMAIL\", \"threshold\": 5, \"users\": [ \"yihui@xxx.com\", \"erhui@xxx.com\" ] &#125; ], \"users\": [ \"yihui@xxx.com\" ] &#125;&#125; III. ConfLoader选择并初始化前面说明，为了确保报警规则的多样性存储与加载，我们支持用户自定义加载类，所以就会有这么个ConfLoaderFactory, 来创建系统中使用的ConfLoader 12345678910111213141516171819202122232425262728293031323334353637383940public class ConfLoaderFactory &#123; private static IConfLoader currentAlarmConfLoader; public static IConfLoader loader() &#123; if (currentAlarmConfLoader == null) &#123; synchronized (ConfLoaderFactory.class) &#123; if (currentAlarmConfLoader == null) &#123; initConfLoader(); &#125; &#125; &#125; return currentAlarmConfLoader; &#125; private static void initConfLoader() &#123; Iterator&lt;IConfLoader&gt; iterator = ServiceLoader.load(IConfLoader.class).iterator(); List&lt;IConfLoader&gt; list = new ArrayList&lt;&gt;(); // 根据优先级进行排序，选择第一个加载成功的Loader while (iterator.hasNext()) &#123; list.add(iterator.next()); &#125; list.sort(Comparator.comparingInt(IConfLoader::order)); for (IConfLoader iConfLoader : list) &#123; if (iConfLoader.load()) &#123; currentAlarmConfLoader = iConfLoader; break; &#125; &#125; if (currentAlarmConfLoader == null) &#123; throw new NoAlarmLoaderSpecifyException(\"no special alarmConfLoader selected!\"); &#125; &#125;&#125; 实现逻辑依旧采取了SPI机制，不够我们定义了一个优先级，默认从最高优先级的开始加载，加载成功之后，就选择这个东西了；否则继续加载下一个，当所有的ConfLoader加载完毕，都没有一个成功的，就抛出一个异常 IV. 小结鉴于篇幅问题，关于报警规则与报警执行器之间的关系，对应的解释器放在下一篇进行说明，简要小结一下本文内容 报警规则： 采用阀值区间方式，将报警频率与报警执行器关联起来 规则加载： 支持SPI方式注入用户加载器，默认提供基于配置文件的加载器，且优先级最低 基本上本文说的就是下面这张图的内容了 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}]},{"title":"2. 报警系统QuickAlarm之报警执行器的设计与实现","slug":"报警系统QuickAlarm之报警执行器的设计与实现","date":"2018-02-09T11:38:59.000Z","updated":"2018-02-13T03:21:17.020Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","excerpt":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现","text":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现 I. AlarmExecute接口定义在定义接口之前，先来根据几个问题来加深下这个概念的理解： 1. 基础知识 说一下这个报警执行器到底是干嘛的？ 执行具体的报警逻辑（感觉说了依据废话） 因此不同的报警方式，可以选择不同的实现，这个强业务关联的逻辑可以交由适用方自己来把控 多个alarmExecute之间如何区分？ 给一个类似身份证的标识，将标识与alarmExecute绑定，则可以报警规则中，用这个标识来表示对应的报警执行器 标识要求全局唯一，否则就没法找到对应的执行器 2. 接口定义根据上面的基础知识，那么很容易给出接口的定义了 123456789101112131415161718192021public interface IExecute &#123; /** * 报警的具体实现 * * @param users 报警用户，支持批量 * @param title 报警信息的title * @param msg 报警的主题信息 */ void sendMsg(List&lt;String&gt; users, String title, String msg); /** * 获取报警单元唯一标识 * * @return name 要求全局唯一 */ default String getName() &#123; return ExecuteNameGenerator.genExecuteName(this.getClass()); &#125;&#125; 第一个方法sendMsg也就是需要使用者来实现的具体执行报警代码的核心模块了，比较清晰，其中用户是列表，因此，支持同时报警给多个用户（但是报警内容都是相同的） 第二个方法getName表示获取标识，默认给了一个实现，规则如下 获取类的 SimpleName 干掉类名后面的 Execute （如果不是以这个结尾的就不需要了） 剩下的全部转大写 实例： SmsExecute -&gt; SMS; LogExecute -&gt; LOG; 3. 额外说明上面接口定义中的sendMsg中，支持给多个用户发送报警信息，如果要求每个报警信息都不同，比如最常见的是: 发送一段文本，其中通知人地方根据报警人来替换，其他的不变 当然这样的场景完全可以自己在实现中来做 传入的content作为一个话术模板 然后利用 String#format() 来实现参数代替 当然更激进一点就是，穿进来的title或者content作为一个key，然后我可以通过这个key，到其他的地方（如db，缓存等）获取报警内容，甚至我连传进来的报警人都不care，直接从其他地方来获取 简单来说，这个实现委托给用户自己实现，你完全可以随意的控制，做任何你想做的事情 II. AlarmExecute的加载1. 问题分析加载AlarmExecut，貌似没有什么特别复杂的东西，一般的思路是创建一个简单工厂类，然后实例化对应的Executor返回，（再多一点确保只有一个实例对象，加以缓存） 这样有什么问题？ 很简单的实现，但是我们需要加载用户自定义的执行器，要怎么支持呢？ 几种可行的解决手段 1. 开放一个注册接口这个可算是最容易想到的了，直接让用户把自己的Executor实例，主动的扔进来 2. 抽象工厂将前面说的简单工厂，改成抽象工厂类，让后具体的加载委托给用户自己来做 3. 借助Spring容器来加载如果所有的AlarmExecute都委托给Spring容器来管理，那么就很简单了，直接通过ApplicationContext#getBean来获取所有的执行器即可 4. SPI加载方式通过JDK的spi机制来实现（详细后面来说） 针对上面的几个手段，首先排除掉前面两个，因为不满足我们的设计目标一： 简单 （只有报警这个接口进行交互，不需要额外的接口调用） 然后也排除掉spring容器，因为我们希望这个东西，可以较独立的被引用到java工程中，后面可以看情况实现一个spring版 从使用来讲，由spring容器来托管的方式，对使用者而言，是最简单，成本最低的，因为不需要额外添加SPI配置 2. 实现我们采用SPI方式来实现加载，对于SPI是什么东西，这里不详细展看，有兴趣的童鞋可以看我之前的一个系类博文：自定义SPI框架设计 实现方式，可说是非常简单了 1234567891011121314151617181920212223242526272829303132333435363738394041public class SimpleExecuteFactory &#123; private static Map&lt;String, IExecute&gt; cacheMap; private static void loadAlarmExecute() &#123; Map&lt;String, IExecute&gt; map = new HashMap&lt;&gt;(); Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); IExecute tmp; while (iExecutes.hasNext()) &#123; tmp = iExecutes.next(); if (!map.containsKey(tmp.getName())) &#123; map.put(tmp.getName(), tmp); &#125; else &#123; throw new DuplicatedAlarmExecuteDefinedException( \"duplicated alarm execute defined!\" + \"\\n\" + \"&gt;&gt;name:\" + tmp.getName() + \"&gt;&gt;&gt;clz:\" + tmp.getClass() + \"&gt;&gt;&gt;clz:\" + map.get(tmp.getName()) ); &#125; &#125; cacheMap = map; &#125; public static IExecute getExecute(String execute) &#123; if (cacheMap == null) &#123; synchronized (SimpleExecuteFactory.class) &#123; if (cacheMap == null) &#123; loadAlarmExecute(); &#125; &#125; &#125; // 如果不存在，则降级为 LogExecute IExecute e = cacheMap.get(execute); return e == null ? cacheMap.get(LogExecute.NAME) : e; &#125;&#125; 上面对外就暴露一个方法，内部比较简单，如果传入标识对应的报警器没有，则返回一个默认的，确保不会因此挂掉 通过SPI加载所有的执行器的逻辑就一行 1Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); 然后需要关注的是循环内部，做了name的唯一性判断，不满足就直接抛出异常了 III. AlarmExecute内部实现内部提供了两个基本的报警实现，比较简单 日志报警执行器 123456789101112131415/** * 有些报警,不需要立即上报,但是希望计数, 当大量出现时, 用于升级 * &lt;p/&gt; * Created by yihui on 2017/4/28. */public class LogExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(LogExecute.class); private static final Logger logger = LoggerFactory.getLogger(\"alarm\"); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; logger.info(\"Do send msg by &#123;&#125; to user:&#123;&#125;, title: &#123;&#125;, msg: &#123;&#125;\", getName(), users, title, msg); &#125;&#125; 空报警执行器 12345678910111213/** * 空报警执行器, 什么都不干 * &lt;p&gt; * Created by yihui on 2017/5/12. */public class NoneExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(NoneExecute.class); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; &#125;&#125; IV. 小结AlarmExecute 的定义，加载以及实现规则目前都已经完成 定义：两个方法，一个执行报警方法，一个返回唯一标识方法 加载：通过SPI方式加载所有定义的alarmExecute 实现：由用户自定义实现IExecute接口，内部逻辑无任务特殊要求，只是需要确保每个executor的name唯一 整个系统的第一步已经迈出，但是有个问题就是什么时候，才会来调用 com.hust.hui.alarm.core.execut.SimpleExecuteFactory#getExecute 从而触发执行器的加载呢？ V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}]},{"title":"1. 报警系统QuickAlarm设计总纲","slug":"报警系统QuickAlarm总纲","date":"2018-02-09T11:37:29.000Z","updated":"2018-02-13T03:21:17.021Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm总纲/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm总纲/","excerpt":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了","text":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了 目标因此我们准备设计一个通用的报警框架 可以自由选择报警方式， 支持用户自定义报警方式拓展 支持动态的报警配置， 支持用户自定义报警规则拓展 支持报警方式自动切换规则设定 支持报警方式自定义自动切换规则拓展 设计整体来说，报警主要可以划分为三个步骤，如下： 提交报警：对外部使用者提供的接口 选择报警：根据报警相关信息，选择具体的报警执行单元 执行报警：实现具体的报警逻辑 从任务划分上来看，比较清晰简单，但是每一块的内容又必须可以拓展， 选择报警： 报警规则的制定 报警规则加载器 ConfLoader 报警规则变更的触发器 ConfChangeTrigger 报警规则解析器 ConfParse ： 解析文本格式报警规则为业务对象 AlarmSelector ：根据报警规则和报警类型，选择具体报警执行器 AlarmExecute 执行报警： 线程池执行（以防止影响主业务流程） AlarmExecute的动态拓展（支持用户自定义的报警器实现） 实际的报警逻辑 根据上面的拆解，在应用启动的时候，就有一些事情必须去做了 ConfLoader的选择 报警规则加载 AlarmExecute的加载（包括默认的+自定义实现的） 下图显示在应用启动时，报警规则解析的相关步骤 至于报警执行器的加载就比较简单了，如下图 因此，整个的工作流程如下图 任务拆解通过前面的任务设计之后，对需要做的东西有了一个大概的脉络了，因此在正式操刀实现之前，下对整个架构进行任务拆解，看下可以具体的执行步骤可以怎么来 最直接的就是设计报警执行器AlarmExecute 定义基本接口 制定自定义扩展规则 接下来就是设计报警规则 如何加载报警规则？ 报警规则具体的定义细则 报警规则的解析：即根据报警类型来获取报警执行器 报警规则动态更新支持 报警线程池 维护报警队列 报警的计数与频率控制 封装对外使用接口 所以，通过上面的分析可以看出，这个系统的结构还是蛮简单的，整个只需要四个部分就可以搞定，其中最主要的就是前面两个了，后面将分别说明 小结做一个东西，当然是希望可以带来一些用处，或者能学习到什么东西，才不枉花费精力来折腾一下，那么我们这个报警系统，究竟有什么用，或者可以从中学习到什么东西呢？ 用途： 支持灵活可配的报警规则，以及具体报警业务的自定义拓展 目标就是统一报警的使用姿势，也就是不管什么报警，都一个姿势，但是内部可以玩出各种花样，对使用者而言就方便简洁了 学习： 抛开特有的知识点，可以抽象一些公共可用的地方，大概就下面这两点了 我们可以如何支持功能的动态可拓展 线程池的使用 IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickAlarm","slug":"Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickAlarm/"}]},{"title":"Java可以如何实现文件变动的监听","slug":"Java可以如何实现文件变动的监听","date":"2018-02-08T04:01:58.000Z","updated":"2018-02-13T03:21:17.018Z","comments":true,"path":"2018/02/08/Java可以如何实现文件变动的监听/","link":"","permalink":"https://zbang.online/hexblog/2018/02/08/Java可以如何实现文件变动的监听/","excerpt":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？","text":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？ I. 问题描述及分析针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 Z+中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下 现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存 一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下： 如何轮询？ 如何判断文件是否修改？ 配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要…） II. 设计与实现问题抽象出来之后，对应的解决方案就比较清晰了 如何轮询 ？ –》 定时器 Timer, ScheduledExecutorService 都可以实现 如何判断文件修改？ –》根据 java.io.File#lastModified 获取文件的上次修改时间，比对即可 那么一个很简单的实现就比较容易了: 12345678910111213141516171819202122232425262728293031public class FileUpTest &#123; private long lastTime; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); // 首先文件的最近一次修改时间戳 lastTime = file.lastModified(); // 定时任务，每秒来判断一下文件是否发生变动，即判断lastModified是否改变 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); &#125; &#125; &#125;,0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？ 定时任务的执行中，如果出现了异常会怎样？ 对上面的代码稍作修改 12345678910111213141516171819202122232425262728293031323334public class FileUpTest &#123; private long lastTime; private void ttt() &#123; throw new NullPointerException(); &#125; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); lastTime = file.lastModified(); ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); ttt(); &#125; &#125; &#125;, 0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 ScheduledExecutorService 的原因了 直接查看ScheduledExecutorService的源码注释说明 If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。 所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了 对应的解决方法也比较简单，整个catch一下就好 III. 进阶版前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列 首先maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 主要是借助这个工具中的 FileAlterationObserver, FileAlterationListener, FileAlterationMonitor 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PropertiesConfListenerHelper &#123; public static boolean registerConfChangeListener(File file, Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; try &#123; // 轮询间隔 5 秒 long interval = TimeUnit.SECONDS.toMillis(5); // 因为监听是以目录为单位进行的，所以这里直接获取文件的根目录 File dir = file.getParentFile(); // 创建一个文件观察器用于过滤 FileAlterationObserver observer = new FileAlterationObserver(dir, FileFilterUtils.and(FileFilterUtils.fileFileFilter(), FileFilterUtils.nameFileFilter(file.getName()))); //设置文件变化监听器 observer.addListener(new MyFileListener(func)); FileAlterationMonitor monitor = new FileAlterationMonitor(interval, observer); monitor.start(); return true; &#125; catch (Exception e) &#123; log.error(\"register properties change listener error! e:&#123;&#125;\", e); return false; &#125; &#125; static final class MyFileListener extends FileAlterationListenerAdaptor &#123; private Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func; public MyFileListener(Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; this.func = func; &#125; @Override public void onFileChange(File file) &#123; Map&lt;String, AlarmConfig&gt; ans = func.apply(file); // 如果加载失败，打印一条日志 log.warn(\"PropertiesConfig changed! reload ans: &#123;&#125;\", ans); &#125; &#125;&#125; 针对上面的实现，简单说明几点： 这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听 如上面registerConfChangeListener方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤 第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象 一个问题，如果 func方法执行时，也抛出了异常，会怎样？ 实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常 那么简单来看一下上面的实现逻辑，直接扣出核心模块 1234567891011121314151617181920212223public void run() &#123; while(true) &#123; if(this.running) &#123; Iterator var1 = this.observers.iterator(); while(var1.hasNext()) &#123; FileAlterationObserver observer = (FileAlterationObserver)var1.next(); observer.checkAndNotify(); &#125; if(this.running) &#123; try &#123; Thread.sleep(this.interval); &#125; catch (InterruptedException var3) &#123; ; &#125; continue; &#125; &#125; return; &#125;&#125; 从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了 JDK版本jdk1.7，提供了一个WatchService，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo 1234567891011121314151617181920212223242526272829303132333435@Testpublic void testFileUpWather() throws IOException &#123; // 说明，这里的监听也必须是目录 Path path = Paths.get(\"/tmp\"); WatchService watcher = FileSystems.getDefault().newWatchService(); path.register(watcher, ENTRY_MODIFY); new Thread(() -&gt; &#123; try &#123; while (true) &#123; WatchKey key = watcher.take(); for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; if (event.kind() == OVERFLOW) &#123; //事件可能lost or discarded continue; &#125; Path fileName = (Path) event.context(); System.out.println(\"文件更新: \" + fileName); &#125; if (!key.reset()) &#123; // 重设WatchKey break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; IV. 小结使用Java来实现配置文件变动的监听，主要涉及到的就是两个点 如何轮询： 定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep 文件修改： File#lastModified 整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是： 千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！ 为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 @Subscribe注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明） V. 其他参考项目 项目： quick-alarm 测试类： FileUpTest.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"File","slug":"File","permalink":"https://zbang.online/hexblog/tags/File/"},{"name":"ScheduledExecutorService","slug":"ScheduledExecutorService","permalink":"https://zbang.online/hexblog/tags/ScheduledExecutorService/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}]},{"title":"Java中变量的初始化顺序","slug":"Java中变量的初始化顺序","date":"2018-02-07T04:28:12.000Z","updated":"2018-02-07T12:30:56.560Z","comments":true,"path":"2018/02/07/Java中变量的初始化顺序/","link":"","permalink":"https://zbang.online/hexblog/2018/02/07/Java中变量的初始化顺序/","excerpt":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因","text":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因 I. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） II. 静态变量初始化顺序类初始化时，会优先初始化静态成员，那么一个类中有多个静态成员时，如何处理的？ 下面是一个使用静态成员，静态代码块，静态方法的测试类，那么下面的输出应该是怎样的呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 输出如下 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 从实际的输出结果来看： 初始化的顺序比较清晰了，压根就是根据初始化代码的先后顺序来的， 且在调用静态方法时，静态方法内部的静态成员已经被初始化 那么问题来了，如果在某个静态成员初始化的时候抛出了异常，会怎样？ 那么稍稍改一下上面的代码，加一个主动抛异常的case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; private static A aError = genError(); private static A genError() &#123; System.out.println(\"gen error!\"); throw new RuntimeException();// return new A(10); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 此时输出： 12345678a init! 1b init! 2gen A: 2a init! 2b init! 1gen error!Exception in thread \"main\" java.lang.ExceptionInInitializerErrorCaused by: java.lang.RuntimeException 也就是说，初始化异常之后的代码将不会在继续执行 那么第二个问题来了，前面说到哪个问题是什么情况 最开始说到，在调用类的静态方法时，发现本该被初始化的静态成员，依然是null，从上面的分析来说，唯一的可能就是在成员变量初始化的过程中，出现了异常 那么，就有另一个问题了，初始化就报错了，这个类的静态方法还能被调用执行么（加入这个静态方法不依赖内部的静态成员）？ 将前面的 genA()方法的private去掉，改成默认的访问范围，然后下面给出一个演示： 通过这个演示，也挺有意思的，第一次访问，会抛出一个初始化异常；但是再调用一次，结果发现居然正常执行了；但是调用public方法时，每次都是抛异常 导致这个问题的原因，还有待考究，但是前面这个问题的答案，估摸着和下面差不多了（但是不敢确定，有待大神指点） 理论上类初始化失败，应该就不允许被调用了 但是某些情况下，可以绕过这个限制 III. 成员变量的初始化测试case也比较简单，把前面的代码中的static去掉即可， 输出 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 依然是根据初始化代码的先后顺序进行的 当然如果出现异常的情况，和前面的结果类似，不再赘述 IV. 小结1. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） 相同等级的初始化的先后顺序，是直接依赖代码中初始化的先后顺序 2. 初始化异常时理论上，类初始化中抛出了异常，那么这个类将无法被classLoader正确的加载，因此也无法有效的使用这个类 但是不排除某些情况下，依然强行的使用了这个类（如上面gif图中的演示），这个原理还不太清晰，也有可能是idea的debug功能有什么黑科技？ 注意 因此，请格外注意，在初始化代码中，请确保不会有抛出异常，如果无法把控，不妨新建一个init()方法来实现初始化各种状态，然后在代码中主动调用好了 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://zbang.online/hexblog/tags/JDK/"},{"name":"Initialize","slug":"Initialize","permalink":"https://zbang.online/hexblog/tags/Initialize/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}]},{"title":"SpringMVC统一异常处理","slug":"SpringMVC统一异常处理","date":"2018-02-04T11:21:15.000Z","updated":"2018-02-04T12:30:54.422Z","comments":true,"path":"2018/02/04/SpringMVC统一异常处理/","link":"","permalink":"https://zbang.online/hexblog/2018/02/04/SpringMVC统一异常处理/","excerpt":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题","text":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题 I. 借助@ControllerAdvice拦截异常给一个简单的demo，便可以很容易的了解这种手段如何处理了 1234567891011121314151617181920@ControllerAdvice@Slf4j@ResponseBodypublic class ActionExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public String defaultHandler(HttpServletRequest request, Exception e) &#123; log.error(\"unexpected exception! request: &#123;&#125;, params: &#123;&#125; refer: &#123;&#125;, e: &#123;&#125;\", request.getRequestURI(), request.getParameterMap(), request.getHeader(\"referer\"), e); if (StringUtils.isBlank(e.getMessage())) &#123; return ResponseWrapper.errorReturn(new Status(500, \"内部异常\")); &#125; else &#123; return ResponseWrapper.errorReturn(new Status(500, e.getMessage())); &#125; &#125;&#125; 这里主要借助两个注解来实现，ControllerAdvice 和 ExceptionHandler II. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Exception","slug":"Exception","permalink":"https://zbang.online/hexblog/tags/Exception/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}]},{"title":" JavaWeb三大组件之Filter学习详解","slug":"JavaWeb三大组件之Filter学习详解","date":"2018-01-26T10:02:01.000Z","updated":"2018-02-13T03:21:17.017Z","comments":true,"path":"2018/01/26/JavaWeb三大组件之Filter学习详解/","link":"","permalink":"https://zbang.online/hexblog/2018/01/26/JavaWeb三大组件之Filter学习详解/","excerpt":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项","text":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项 I. 基本知识Filter称之为过滤器，是用来做一些拦截的任务， 在Servlet接受请求之前，做一些事情，如果不满足限定，可以拒绝进入Servlet 从上面的图，可以看出一个Filter的工作流程: 一个http请求过来之后 首先进入filter，执行相关业务逻辑 若判定通行，则进入Servlet逻辑，Servlet执行完毕之后，又返回Filter，最后在返回给请求方 判定失败，直接返回，不需要将请求发给Servlet 通过上面的流程，可以推算使用场景： 在filter层，来获取用户的身份 可以考虑在filter层做一些常规的校验（如参数校验，referer校验等） 可以在filter层做稳定性相关的工作（如全链路打点，可以在filter层分配一个traceId；也可以在这一层做限流等） 1. 基本使用姿势要使用一个Filter，一半需要两步，实现Filter接口的自定义类，web.xml中对filter的定义 1234567891011public interface Filter &#123; public void init(FilterConfig filterConfig) throws ServletException; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public void destroy();&#125; 主要就三个方法，从命名来看， 也比较清晰，在创建Filter对象的时候，调用 init 方法 销毁Filter对象的时候，调用 destroy 方法 当请求过来之后，调用 doFilter，也就是主要的业务逻辑所在了 详细case后面再说 接下来就是xml的配置了，和Servlet类似，每自定义一个，都需要在xml中加上一个配置（挺繁琐的操作的） 123456789101112131415161718&lt;!-- 解决乱码的问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置也比较简单了，一个 一个 前者定义具体的Filter，后者表示这个Filter拦截的URL （看起来和Servlet的配置规则没什么两样） II. 实例我们的实例，就拿大名鼎鼎的CharacterEncodingFilter来说明，顺带膜拜下Spring的大神的优秀源码 123456789101112131415161718192021222324252627282930313233343536373839404142public class CharacterEncodingFilter extends OncePerRequestFilter &#123; private String encoding; private boolean forceEncoding = false; public CharacterEncodingFilter() &#123; &#125; public CharacterEncodingFilter(String encoding) &#123; this(encoding, false); &#125; public CharacterEncodingFilter(String encoding, boolean forceEncoding) &#123; Assert.hasLength(encoding, \"Encoding must not be empty\"); this.encoding = encoding; this.forceEncoding = forceEncoding; &#125; public void setEncoding(String encoding) &#123; this.encoding = encoding; &#125; public void setForceEncoding(boolean forceEncoding) &#123; this.forceEncoding = forceEncoding; &#125; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response); System.out.printl(\"servelt 执行完成，又返回filter\"); &#125;&#125; 上面的实现比较简单，主要将视线集中在 doFilterInternal 方法内部，如果要设置编码参数，则直接修改 HttpServletRequest, HttpServletResponse 两个参数，操作完成之后，执行下面这一行 1filterChain.doFilter(request, response); 注意 上面这一行执行，表示Filter层已经通过了，请求可以转发给下一个Filter或者直接传给Servlet 而下一个Filter, Servlet执行完成之后，还会继续往下走，就是上面的那一行输出，也会被调用（那一行是我加的，源码中没有） 所以，如果你不希望继续往下走，那么就简单了，不执行上面的那一行即可 疑问问题一：看了上面的源码，一个很明显的问题就是，参数怎么设置的？ 仔细看上面的源码，发现自定义Filter是继承 org.springframework.web.filter.OncePerRequestFilter 而不是直接实现的 Filter 接口，而且方法内也没有显示的实现 init()方法，所有很容易猜到是父类中实现了参数的初始化过程 具体的实现逻辑是在 org.springframework.web.filter.GenericFilterBean#init 中，同样是Spring实现的，主要代码捞出来 12345678910111213141516171819202122232425262728293031public final void init(FilterConfig filterConfig) throws ServletException &#123; Assert.notNull(filterConfig, \"FilterConfig must not be null\"); if (logger.isDebugEnabled()) &#123; logger.debug(\"Initializing filter '\" + filterConfig.getFilterName() + \"'\"); &#125; this.filterConfig = filterConfig; // Set bean properties from init parameters. try &#123; PropertyValues pvs = new FilterConfigPropertyValues(filterConfig, this.requiredProperties); BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(filterConfig.getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.environment)); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; String msg = \"Failed to set bean properties on filter '\" + filterConfig.getFilterName() + \"': \" + ex.getMessage(); logger.error(msg, ex); throw new NestedServletException(msg, ex); &#125; // Let subclasses do whatever initialization they like. initFilterBean(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Filter '\" + filterConfig.getFilterName() + \"' configured successfully\"); &#125;&#125; 看上面一大串的代码，到底干了嘛？ 简单来讲，就是获取xml中配置的参数，然后填充到Filter对象中（对Srping而言，CharacterEncodingFilter就是一个bean），这个具体的逻辑和本篇关系不大，就直接跳过了 问题二：在Filter层中可以获取参数么 从doFilter的方法签名中看，既然有Request参数，那么应该是可以获取到请求参数的，那么实际验证一下 先实现一个最最最简单的Filter 123456789101112131415161718public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in filter\"); System.out.println(\"args: \" + JSON.toJSONString(request.getParameterMap())); chain.doFilter(request, response); System.out.println(\"out filter\"); &#125; @Override public void destroy() &#123; &#125;&#125; 开始测试 1curl -d 'name=Hello&amp;password=world' http://127.0.0.1:8088/123 输出如下 123in filterargs: &#123;\"name\":[\"Hello\"],\"password\":[\"world\"]&#125;out filter 注意 在Filter中获取参数时，最好不要直接使用获取请求流的方式，如果获取请求流，那么Servlet就获取不到请求参数了 问题三：多个filter的顺序怎么定 前面学习Servlet的时候，也有这个问题，一个URL被多个Servlet命中了，那么先后顺序是怎样的呢？ 精确匹配 &gt; 最长匹配 &gt; 其他模糊匹配 &gt; 没有匹配的则是404 那么Filter呢，他们的区别还是比较明显的，很多Filter都是拦截所有的请求，即很多Filter的命中规则都是一样的，那么怎么办？ 先执行带有url-pattern标签的filter，再执行带有servlet-name标签的filter 如果同为url-pattern或servlet-name，则会按照在web.xml中的声明顺序执行 测试case如下，我们定义三个Filter： TestFilter: 匹配所有路径 ATestFilter: 匹配所有路径 ServletFilter: 匹配 mvc-servlet 123456789101112131415161718192021// ATestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ATestFilter\"); chain.doFilter(request, response);&#125;// TestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in TestFilter\"); chain.doFilter(request, response);&#125;// ServletFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ServletFilter\"); chain.doFilter(request, response);&#125; 对应的xml配置如下 123456789101112131415161718192021222324252627282930&lt;filter&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ServletFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.TestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ATestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 输出结果 123in TestFilterin ATestFilterin ServletFilter III. 小结Filter 通常用于JavaWeb的过滤使用，通过doFilter方法中执行 chain.doFilter(request, response);，进入下一个Filter或者Servlet执行逻辑，当执行完成之后，依然会回到Filter这一层，继续走下去 针对上面的逻辑，Filter的常见应用场景有： 用户信息获取，身份校验 安全校验（referer校验失败，直接拒绝） 稳定性相关（限流，监控埋点，全链路日志埋点） Filter的执行顺序： url-mapping 的优先执行，其次是 servlet-mapping 同一个匹配方式（如都是url-mapping）中，根据在xml中定义的先后顺序来确定 Filter的注意事项： 正常业务，请记得一定执行 chain.doFilter(request, response)， 最后把它放在finnal块中，防止你在Filter中的代码抛异常导致进入不到后续的逻辑 在Filter中不要直接获取请求数据流（请求流被读取完之后，Servlet就get不到了!） IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JavaWeb","slug":"Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Filter","slug":"Filter","permalink":"https://zbang.online/hexblog/tags/Filter/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JavaWeb","slug":"Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/Java/JavaWeb/"}]},{"title":"JavaWeb三大组件之Servlet学习","slug":"JavaWeb三大组件之Servlet学习","date":"2018-01-24T01:55:49.000Z","updated":"2018-02-13T03:21:17.017Z","comments":true,"path":"2018/01/24/JavaWeb三大组件之Servlet学习/","link":"","permalink":"https://zbang.online/hexblog/2018/01/24/JavaWeb三大组件之Servlet学习/","excerpt":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置","text":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置 I. 基本知识点1. 什么是ServletServlet是JavaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要： 接受请求 处理请求 完成响应 2. 怎么玩Servlet一般来讲，创建一个自定义的Servlet有两个步骤，在web.xml中配置serverlt的声明；实现Servlet接口，实现自定义的Servlet逻辑 一个简单的case如下 web.xml中，添加配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实现自定义Servlet 1234567891011public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125;&#125; 上面这个Servlet，实现了拦截 /study 下的所有请求， 然后返回一段文本，上面作为演示，具体的展开下面说明 3. Servlet接口说明上面是直接继承了HttpServlet，可能没法完全的暴露一个Servlet的具体接口有哪些，以及它的生命周期是怎样的，接下来则直接针对源头进行说明 1234567891011121314151617public interface Servlet &#123; // 初始化 public void init(ServletConfig config) throws ServletException; // 获取配置信息 public ServletConfig getServletConfig(); // 处理请求 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; // Returns information about the servlet, such as author, version, and copyright public String getServletInfo(); // 销毁 public void destroy();&#125; 五个方法，从命名也可以看出对应的生命周期 首先是创建： init() 方法被创建 创建完毕之后，请求来了，分给 service方法，执行对应的业务逻辑 最后不想玩了，就销毁掉，此时触发 destroy方法 说明 在Servlet被创建后，服务器会马上调用Servlet的void init(ServletConfig)方法。请记住， Servlet出生后马上就会调用init()方法，我们可以把一些对Servlet的初始化工作放到init方法中，今后所有分配到这个Servlet的请求，都是公用这个Servlet的 4. ServletConfig init()方法的参数 ServletConfig对象对应web.xml文件中的元素。例如你想获取当前Servlet在web.xml文件中的配置名，那么可以使用servletConfig.getServletName()方法获取 1234String getServletName()：获取Servlet在web.xml文件中的配置名称，即指定的名称； ServletContext getServletContext()：用来获取ServletContext对象，ServletContext会在后面讲解； String getInitParameter(String name)：用来获取在web.xml中配置的初始化参数，通过参数名来获取参数值； Enumeration getInitParameterNames()：用来获取在web.xml中配置的所有初始化参数名称； 5. ServletRequest 请求对象，可以从其中获取请求数据，请求头等 内部提供的方法挺多，通常我们最关心的有: 获取参数: javax.servlet.ServletRequest#getParameter 获取头 : javax.servlet.http.HttpServletRequest#getHeader 获取cookie: javax.servlet.http.HttpServletRequest#getCookies 获取请求 : javax.servlet.http.HttpServletRequest#getRequestURI … 还有一个比较重要的就是指定字符编码，如我们通常要求提交的参数满足utf8编码，这时就可以如下设置 12// javax.servlet.ServletRequest#setCharacterEncodingrequest.setCharacterEncoding(&quot;utf-8&quot;); 如我们最常用的一个spring的fitler，关键代码如下 123456789101112131415// org.springframework.web.filter.CharacterEncodingFilter#doFilterInternal// @Overrideprotected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response);&#125; 6. ServletResponse 返回对象，返回响应给调用方的结构，设置返回头 返回数据给调用方，主要就是利用这个东西了，内部提供的方法也不少，我们主要关心的其实也并不太多 设置返回头：javax.servlet.http.HttpServletResponse#setHeader 添加cookie: javax.servlet.http.HttpServletResponse#addCookie 重定向 : javax.servlet.http.HttpServletResponse#sendRedirect 异常 : javax.servlet.http.HttpServletResponse#sendError 设置ContentType: javax.servlet.ServletResponse#setContentType 设置返回流: javax.servlet.ServletResponse#getOutputStream, javax.servlet.ServletResponse#getWriter 设置编码: javax.servlet.ServletResponse#setCharacterEncoding II. 进阶1. web.xml中配置 这个配置，主要针对 Servlet 的顺序指定，URL匹配这两个问题，所以有必要研究下这个配置中的说明 通常web.xml的配置，下面两个是必须的 1234567891011121314&lt;!-- servlet的配置 --&gt;&lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;com.xxx.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中 servlet-mapping 指定映射的路径，满足条件的会匹配对应的Servlet，匹配规则有以下几个定义 必须 / 开头 /servlet 表示精确匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlets 不匹配 http://localhost:8088/servlet/123 不匹配 /servlet/* 表示目录匹配，所有servlet路径开头的都可以匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlet/123 匹配 http://localhost:8088/servlet/123/123 匹配 http://localhost:8088/servlets 不匹配 /*.do 表示扩展名匹配，所有以 .do 结尾的匹配 既然这个url匹配支持模糊匹配，那么问题来了，如果两个servlet都匹配了这个path路径，那么到底是哪个处理呢？ 注意到前面有个配置参数：load-on-startup 当值为0或者大于0时，表示容器在应用启动时就加载这个servlet； 当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载 正数的值越小，启动该servlet的优先级越高 注意 这个参数是加载顺序，而不是最终的匹配顺序 那么匹配顺序的优先级是： 精确路径匹配 比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了 最长路径匹配 servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源，即匹配defaultServlet 2. 参数获取 参数获取，则主要区分get请求参数，post提交表单，上传的文件了 a. 通过 getQueryString这种获取参数的方式，只能获取url上面的参数，无法获取到post的表单内容 1String str = req.getQueryString(); b. 通过 getParameter12// 返回所有的请求参数javax.servlet.ServletRequest#getParameterMap 这种使用姿势，和我们在SpringMVC中常见的基本一致 c. 通过 getInputStream获取请求流，一般的使用姿势如下 1234InputStream stream = req.getInputStream();byte[] bytes = new byte[stream.available()];stream.read(bytes);String str = new String(bytes); 然后就需要自己对上面的请求参数进行处理了；两厢对比，常规的获取方法，直接使用 getParameter方式更加优雅 注意 通过getInputStream方式获取了请求数据之后，再通过 getParameter获取不到参数的，也好理解，请求的流，被你读取之后，其他的地方就无法获取流中的数据了 d. 获取上传的文件从请求参数中获取上传的文件，网上随意搜索了一下，发现大部分都使用apache的fileupload包， 其实处理的依然是inputstream这个请求流，只是逻辑比较复杂，粗略的翻看了一下源码，发现这一块还挺有意思的，准备单独的深入看一下 3. 数据返回返回数据，前面介绍HttpServletResponse的时候，就给出了两个方法 a. getWriter1public PrintWriter getWriter() throws IOException; b. getOutputStream1public ServletOutputStream getOutputStream() throws IOException; 下面简单说一下上面的区别 PrintWriter ServletOutputStream 字符流返回 字节流返回 需要字符编码 字节流直接返回（返回文件就很占优势了） 说明 上面两种方式互斥，只能使用其中一种case Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象 4. 返回头设置常见的请求头和返回头设置，对于servlet而言也是比较常见的，一般常见的几个设置 是否缓存，缓存时间 设置cookie 设置 corss-origin 相关，以支持跨域 设置 content-type… 而实际的使用也比较简单了，如下即可 12# javax.servlet.http.HttpServletResponse#addHeaderresponse.addHeader(\"Content-Type\", \"text/html; charset=UTF-8\"); III. 实例测试创建一个自定义的嗯Servlet，然后拦截所有 /study 下面的请求 1234567891011121314151617public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; Map map = req.getParameterMap(); System.out.println(\"arg: \" + map); res.getWriter().append(\"success\").flush(); &#125;&#125; 对应的xml配置如下 123456789 &lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实测演示： IV. 其他参考 servlet详解(第一篇) 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JavaWeb","slug":"Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://zbang.online/hexblog/tags/Servlet/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JavaWeb","slug":"Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/Java/JavaWeb/"}]},{"title":"Android学习之旅1D:首屏页的开发","slug":"Android学习之旅1D-首屏页的开发","date":"2018-01-22T12:16:18.000Z","updated":"2018-01-22T12:30:56.393Z","comments":true,"path":"2018/01/22/Android学习之旅1D-首屏页的开发/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/Android学习之旅1D-首屏页的开发/","excerpt":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程","text":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程 I. 前置主要copy两个开源项目 JianshuApp SUESNews 上面两个工程，第二个用到的依赖比较少，实现的基本功能也都很ok，而第一个里面则用了很多有意思的第三方框架，但是目前我看不太懂，所以第一版以SUESNews作为主要的学习目标 所以，第一版的目标是： 实现基本功能 完成主体业务逻辑 II. Splash页面开发一般来将，进入app之前，会进入一个类似首屏页的页面（比如12306的显示广告啥的），那么第一件事情就是做这个了 1. 做什么这个页面，主要显示的东西比较简单了 上边是一个图片，右上角一个倒计时 下边显示的应用信息，版本等 业务逻辑： 显示广告（😄），点击进入相应的详情页 判断是否登录，若未登录，则进入登录页 若已经登录，则进入主APP 2. 开动a. 全屏进入的首页，所以状态栏，标题啥的都不要，主要的逻辑如下 styles.xml 文件中新增 1234&lt;style name=\"AppTheme.FullScreen\"&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 其次，就是在定义的Activity中，使用对应的style AndroidManifest.xml 1234567&lt;activity android:name=\".ui.SplashActivity\" android:theme=\"@style/AppTheme.FullScreen\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; b. xml实现activity_splash.xml 对应的实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"false\" tools:context=\"com.yihui.yifeng.ui.SplashActivity\"&gt; &lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignBottom=\"@+id/title_text\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt; &lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:textStyle=\"bold\" tools:text=\"Copyright @2017-2018 一封 | 小灰灰技术支持\" /&gt;&lt;/RelativeLayout&gt; 运行截图如下： 上面这个布局，是直接使用可视化的拖拽的，所以操作起来挺蛋疼的，而且最终的结果也不太好，下面单独的开一节来研究下这个布局的东西了 c. Activity的实现上面是xml的配置，当然还得有对应的实体类了，大部分逻辑是直接从参考的工程中copy过来的，所以相关的动画配置，图片也是直接扣过来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SplashActivity extends Activity &#123; private ImageView mBackgroundImage; private ImageView infoBgImg; private TextView mTitleText; private TextView mVersionText; private int[] ary = new int[] &#123;R.drawable.pic_background_1, R.drawable.pic_background_2, R.drawable.pic_background_3, R.drawable.pic_background_4&#125;; private int getBgDrawable() &#123; return ary[new Random().nextInt(ary.length)]; &#125; private void initInfoBg() &#123; infoBgImg = findViewById(R.id.image_info_bg); infoBgImg.setImageDrawable(getResources().getDrawable(ary[0])); &#125; private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome); mBackgroundImage.startAnimation(animImage); animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); // 下半的提示文案信息 initInfoBg(); // 上半的广告动画 initAdBg(); &#125;&#125; todo登录状态判断，如果未登录，则应该跳转到登录页面；否则才是跳转到主页 III. 知识点小结上面只是实现了一个简单的应用开启页面，但也涉及了几个有趣的知识点，下面来深入一下 1. RelativeLayout 布局控件的位置是按照相对位置来计算的，后一个控件在什么位置依赖于前一个控件的基本位置，是布局最常用，也是最灵活的一种布局 常见的属性值 123456789101112131415161718192021222324第一类:属性值为true或falseandroid:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中android:layout_alignParentBottom 贴紧父元素的下边缘android:layout_alignParentLeft 贴紧父元素的左边缘android:layout_alignParentRight 贴紧父元素的右边缘android:layout_alignParentTop 贴紧父元素的上边缘 第二类：属性值必须为id的引用名“@id/id-name”android:layout_below 在某元素的下方android:layout_above 在某元素的的上方android:layout_toLeftOf 在某元素的左边android:layout_toRightOf 在某元素的右边android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐第三类：属性值为具体的像素值，如30dip，40pxandroid:layout_marginBottom 离某元素底边缘的距离android:layout_marginLeft 离某元素左边缘的距离android:layout_marginRight 离某元素右边缘的距离android:layout_marginTop 离某元素上边缘的距离 所以可以简单的修改一下上面的布局，相对布局的样式就两个，上面一个图，下面一个图 1234567891011121314151617181920&lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行 --&gt; android:layout_alignBottom=\"@+id/image_info_bg\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt;&lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行，确保背景图可以包含文本信息 --&gt; android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; 那么剩下的两个文本显示就可以直接指定下边距来确定位置了 123456789101112131415161718192021222324&lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt;&lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:text=\"@string/splash_copyright\" /&gt; 2. 获取组件在Activity中，先要绑定视图，然后再获取view进行相关的操作（如修改值，绑定事件等） 12345678910// Activity 的 oncreate方法中，进行初始化// 绑定视图super.onCreate(savedInstanceState);setContentView(R.layout.activity_splash);// 获取组件findViewById(R.id.image_info_bg);// 获取资源，如图片Drawable drawable = getResources().getDrawable(R.drawable.pic_background_1) 有一个非常有名的工具叫做 butterknife, 可以通过注解的方式来解决 findViewById这种频繁的调用姿势，这个放在后续的进阶版中使用 3. 设置动画开屏使用了一个图片放大的动画，持续3s，动画播放完毕之后跳转主页；所以这里有个有趣的知识点就是如何使用xml来配置动画效果，从实现来看也挺简单的 123456789101112131415161718192021222324// 解析xml配置为 Animation 对象Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome);// 设置组件的动画属性mBackgroundImage.startAnimation(animImage);// 配置监听事件animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; // 动画结束后的回调 @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125;&#125;); 对应的xml配置如下 image_welcome.xml 1234567891011&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:fromXScale=\"1.0\" android:toXScale=\"1.3\" android:fromYScale=\"1.0\" android:toYScale=\"1.3\" android:duration=\"3000\" android:pivotY=\"50%\" android:pivotX=\"50%\" /&gt;&lt;/set&gt; 那么，我们需要实现开头说的，这个图片如果是个广告，点击时展开详情页；右上角显示一个倒计时的小控件，可以怎么处理？（看最后） 4. 页面跳转从一个Activity跳转到另一个，常见的使用姿势如下 1startActivity(new Intent(SplashActivity.this, MainActivity.class)); IV. 倒计时改进如何使用倒计时来替换前面的动画呢？最容易想到的就是用Timer或者ScheduleService来实现一个计时器，当然这是一个后端java的想法，对于Android呢，特意查了一下，发现有个 CountDownTimer 的类，专门干这个的，所以简单的改造一下 12345678910111213141516171819202122232425262728private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); mBackgroundImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 点击 Toast.makeText(SplashActivity.this, \"点击了\", Toast.LENGTH_SHORT).show(); &#125; &#125;); final TextView countDown = findViewById(R.id.splash_timedown); CountDownTimer timer = new CountDownTimer(10000, 1000) &#123; @Override public void onTick(long l) &#123; countDown.setText(\"倒计时:\" + (l / 1000) + \"s\"); &#125; @Override public void onFinish() &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; &#125;; timer.start();&#125; 改造后的输出图, 注意右上角的时间，已经下面分割处，不会有前面的空白了 V. 其他额外话感觉最近不太能专心下来学习一门技术，有点浮躁了，所以决定学习下andorid，锻炼下自己，初步规划，先入门，然后接收一些有趣的第三方框架，最后再试一下kotalin Android学习第一天，总感觉这将是个漫长的过程，也不晓得最终会完成得怎么样，努力坚持吧 扫描关注，java分享","categories":[{"name":"Android","slug":"Android","permalink":"https://zbang.online/hexblog/categories/Android/"},{"name":"一封","slug":"Android/一封","permalink":"https://zbang.online/hexblog/categories/Android/一封/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://zbang.online/hexblog/tags/Android/"},{"name":"一封","slug":"一封","permalink":"https://zbang.online/hexblog/tags/一封/"},{"name":"RelativeLayout","slug":"RelativeLayout","permalink":"https://zbang.online/hexblog/tags/RelativeLayout/"},{"name":"CountDownTimer","slug":"CountDownTimer","permalink":"https://zbang.online/hexblog/tags/CountDownTimer/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://zbang.online/hexblog/categories/Android/"},{"name":"一封","slug":"Android/一封","permalink":"https://zbang.online/hexblog/categories/Android/一封/"}]},{"title":"兼容ImageIO读取jpeg图片变红","slug":"兼容ImageIO读取jpeg图片变红","date":"2018-01-22T06:38:39.000Z","updated":"2018-02-13T03:21:17.019Z","comments":true,"path":"2018/01/22/兼容ImageIO读取jpeg图片变红/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/兼容ImageIO读取jpeg图片变红/","excerpt":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case","text":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case 问题重现有问题的图片： 测试验证代码 123456789101112/** * 图片读取之后，颜色变红的测试 */@Testpublic void testLoadRedImg() throws IOException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); BufferedImage bf = ImageIO.read(u); ImageIO.write System.out.println(\"--over--\");&#125; debug截图如下： 问题兼容不实用ImageIO来加载图片，改用Toolkit来实现图片读取，然后再将读取到的图片绘制到BufferedImage对象上 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void testLoadRedImg2() throws MalformedURLException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); Image img = Toolkit.getDefaultToolkit().getImage(u); BufferedImage bf = toBufferedImage(img); System.out.println(\"eeee\");&#125;static BufferedImage toBufferedImage(Image image) &#123; if (image instanceof BufferedImage) &#123; return (BufferedImage) image; &#125; // This code ensures that all the pixels in the image are loaded image = new ImageIcon(image).getImage(); BufferedImage bimage = null; GraphicsEnvironment ge = GraphicsEnvironment .getLocalGraphicsEnvironment(); try &#123; int transparency = Transparency.OPAQUE; GraphicsDevice gs = ge.getDefaultScreenDevice(); GraphicsConfiguration gc = gs.getDefaultConfiguration(); bimage = gc.createCompatibleImage(image.getWidth(null), image.getHeight(null), transparency); &#125; catch (HeadlessException e) &#123; // The system does not have a screen &#125; if (bimage == null) &#123; // Create a buffered image using the default color model int type = BufferedImage.TYPE_INT_RGB; bimage = new BufferedImage(image.getWidth(null), image.getHeight(null), type); &#125; // Copy image to buffered image Graphics g = bimage.createGraphics(); // Paint the image onto the buffered image g.drawImage(image, 0, 0, null); g.dispose(); return bimage;&#125; 实测验证 为什么会出现这个问题： ImageIO.read()方法读取图片时可能存在不正确处理图片ICC信息的问题，ICC为JPEG图片格式中的一种头部信息，导致渲染图片前景色时蒙上一层红色。 其他参考 Java处理某些图片红色问题 扫描关注，java分享","categories":[{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/categories/BugFix/"},{"name":"Java","slug":"BugFix/Java","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/"},{"name":"Image","slug":"BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/Image/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/tags/BugFix/"},{"name":"BufferedImage","slug":"BufferedImage","permalink":"https://zbang.online/hexblog/tags/BufferedImage/"},{"name":"Jpeg","slug":"Jpeg","permalink":"https://zbang.online/hexblog/tags/Jpeg/"}],"keywords":[{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/categories/BugFix/"},{"name":"Java","slug":"BugFix/Java","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/"},{"name":"Image","slug":"BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/Image/"}]},{"title":"Batik渲染png图片异常的bug修复","slug":"Batik渲染png图片异常的bug修复","date":"2018-01-20T12:36:56.000Z","updated":"2018-02-13T03:21:17.017Z","comments":true,"path":"2018/01/20/Batik渲染png图片异常的bug修复/","link":"","permalink":"https://zbang.online/hexblog/2018/01/20/Batik渲染png图片异常的bug修复/","excerpt":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程","text":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程 I. 问题重现svg文件: 123456&lt;svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;&lt;image y=\"0\" width=\"100%\" height=\"100%\" x=\"0\" xlink:href=\"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"/&gt; &lt;!--xlink:href=\"https://s17.mogucdn.com/mlcdn/c45406/180119_46ld8kkb54d3el06hela5d61e18f5_1024x966.png\"/&gt;--&gt; &lt;!--xlink:href=\"http://avatar.csdn.net/A/8/B/3_u010889145.jpg\"/&gt;--&gt;&lt;/svg&gt; 依次测试了三个图片，两个png，一个jpg，很不幸第一个png会抛异常 输出的堆栈信息如 12345678910111213141516The URI \"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"on element &lt;image&gt; can't be opened because:PNG URL is corrupt or unsupported variant at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) at org.apache.batik.bridge.SVGImageElementBridge.buildImageGraphicsNode(SVGImageElementBridge.java:180) at org.apache.batik.bridge.SVGImageElementBridge.createGraphicsNode(SVGImageElementBridge.java:122) at org.apache.batik.bridge.GVTBuilder.buildGraphicsNode(GVTBuilder.java:213) at org.apache.batik.bridge.GVTBuilder.buildComposite(GVTBuilder.java:171) at org.apache.batik.bridge.GVTBuilder.build(GVTBuilder.java:82) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:208) at org.apache.batik.transcoder.image.ImageTranscoder.transcode(ImageTranscoder.java:92) at org.apache.batik.transcoder.XMLAbstractTranscoder.transcode(XMLAbstractTranscoder.java:142) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:156) ... II. 问题定位及分析既然出现了这个问题，那么就要去修复解决了，当然遇到这么鬼畜的问题，最常见的几个步骤： 其他人遇到过么 （问百度） – 结果度娘没有给出任何有效的建议，也没有搜到任何有用的信息 然后问谷歌，靠谱了一点，至少有些相关的主题了，但建设性的意见也没收到 外援实在找不到，只能debug查问题了 1. DEBUG的一路通过上面的堆栈信息，可以想见，debug的几个地方也和明确了，首先定位到下面这一行 1at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) 为什么这么干？因为首先得确认下这个异常是怎么抛出来的，逆向推，直接看源码，发现直接抛出异常 再往上走 1at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) 所以说因为这个if条件判断成立，导致进入了这个异常逻辑，判断的逻辑也没啥好说的，现在的关键是这个参数对象img是怎么来的 1at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) 然后就稍微清晰一点了，直接将火力放在下面的方法中 12345org.apache.batik.ext.awt.image.spi.ImageTagRegistry#readURL(java.io.InputStream, org.apache.batik.util.ParsedURL, org.apache.xmlgraphics.java2d.color.ICCColorSpaceWithIntent, boolean, boolean) 在这个方法内部，也没什么好说的，单步多调几次，就能发现异常的case是怎么来的了，省略掉中间各种单步debug的过程，下面直接进入关键链路 2. 火力全开，问题定位1org.apache.batik.ext.awt.image.codec.imageio.AbstractImageIORegistryEntry 通过上面的一路之后，发现最终的关键就是上面这个抽象类，顺带也可以看下这个抽象类的几个子类，有JPEGxxx, PNGxxx, TIFFxxx，然后问题来了，都已经有相关实现了，所以png讲道理应该是会支持的才对吧，但和实际的表现太不一样了吧，所以有必要撸一把源码了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public Filter handleStream(InputStream inIS, ParsedURL origURL, boolean needRawData) &#123; final DeferRable dr = new DeferRable(); final InputStream is = inIS; final String errCode; final Object [] errParam; if (origURL != null) &#123; errCode = ERR_URL_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName(), origURL&#125;; &#125; else &#123; errCode = ERR_STREAM_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName()&#125;; &#125; Thread t = new Thread() &#123; @Override public void run() &#123; Filter filt; try&#123; Iterator&lt;ImageReader&gt; iter = ImageIO.getImageReadersByMIMEType( getMimeTypes().get(0).toString()); if (!iter.hasNext()) &#123; throw new UnsupportedOperationException( \"No image reader for \" + getFormatName() + \" available!\"); &#125; ImageReader reader = iter.next(); ImageInputStream imageIn = ImageIO.createImageInputStream(is); reader.setInput(imageIn, true); int imageIndex = 0; dr.setBounds(new Rectangle2D.Double (0, 0, reader.getWidth(imageIndex), reader.getHeight(imageIndex))); CachableRed cr; //Naive approach possibly wasting lots of memory //and ignoring the gamma correction done by PNGRed :-( //Matches the code used by the former JPEGRegistryEntry, though. BufferedImage bi = reader.read(imageIndex); cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image); filt = new RedRable(cr); &#125; catch (IOException ioe) &#123; // Something bad happened here... filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; catch (ThreadDeath td) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); dr.setSource(filt); throw td; &#125; catch (Throwable t) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; dr.setSource(filt); &#125; &#125;; t.start(); return dr;&#125; 看上面的实现是一个非常有意思的事情， 开了一个线程做事情，而且直接就返回了，相当于给了别人一个储物箱的钥匙，虽然现在储物箱是空的，但是回头我会填满的 言归正传，主要的业务逻辑就在这个线程里了，核心的几行代码就是 123456789101112// 加载图片，转为BufferedImage对象BufferedImage bi = reader.read(imageIndex);cr = GraphicsUtil.wrap(bi);// 下面实现对图片的ARGB进行修改cr = new Any2sRGBRed(cr);cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre);WritableRaster wr = (WritableRaster)cr.getData();ColorModel cm = cr.getColorModel();BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null);cr = GraphicsUtil.wrap(image);filt = new RedRable(cr); debug上面的几行代码，发现问题比较明显了，就是这个图片的转换跪了，至于为啥？ java的图片各种蛋疼至极，这里面的逻辑，真心搞不进去，so深挖到此为止 III. 兼容逻辑问题定位到了，当然就是想办法来修复了，简单来说，需要兼容的就是图片的类型转换上了，直接用原来的可能会抛异常，所以做了一个简单的兼容逻辑 12345678910111213141516if(bi.getType() == BufferedImage.TYPE_BYTE_INDEXED) &#123; BufferedImage image = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = image.createGraphics(); g2d.drawImage(bi, 0, 0, null); g2d.dispose(); cr = GraphicsUtil.wrap(image);&#125; else &#123; cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image);&#125; 再次验证，ok 注意： 一个问题来了，上面的兼容是需要修改源码的，我们可以怎么办？有几种解决方法 猥琐方法一：down下源码，修改版本，然后传到自己的私服，使用自己的vip包 猥琐方法二：把 batik-codec 工程原样拷贝到自己的项目中，就可以随意的使用改了 猥琐方法三：写一个完全相同的类（包路径完全相同），然后构造一个自定义类加载器，加载这个自己的这个兼容版本的，替换原来的（未测试，不确定是否能行） 至于我的选择，就是使用了猥琐方法二 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/categories/BugFix/"},{"name":"Java","slug":"BugFix/Java","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/"},{"name":"Image","slug":"BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/Image/"}],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"https://zbang.online/hexblog/tags/Bugfix/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"batik","slug":"batik","permalink":"https://zbang.online/hexblog/tags/batik/"},{"name":"Png","slug":"Png","permalink":"https://zbang.online/hexblog/tags/Png/"}],"keywords":[{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/categories/BugFix/"},{"name":"Java","slug":"BugFix/Java","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/"},{"name":"Image","slug":"BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/BugFix/Java/Image/"}]},{"title":"SpringMVC支持跨域的几种姿势","slug":"SpringMVC支持跨域的几种姿势","date":"2018-01-19T07:43:38.000Z","updated":"2018-01-18T12:30:56.242Z","comments":true,"path":"2018/01/19/SpringMVC支持跨域的几种姿势/","link":"","permalink":"https://zbang.online/hexblog/2018/01/19/SpringMVC支持跨域的几种姿势/","excerpt":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数","text":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数 I. Jsonp的支持jsonp的请求表现方式就是url里面会多一个参数 callback，一般如下 1callback=jQuery21105810685605043302_1516257942328 jsonp的返回与一般调用方式的返回也会有点区别，会在外面包装一层，如 1jQuery21105810685605043302_1516257942328(...); springmvc中，jsonp的支持却是比较简单了，不需要对现有的接口进行任何处理，只需要像下面这么玩即可 123456@ControllerAdvicepublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice &#123; public JsonpAdvice() &#123; super(\"callback\"); &#125;&#125; 分析说明首先是利用了注解 @ControllerAdvice ， 这个注解在后面说到的统一异常处理时，也会用到，从命名也可以看出，就是为Controller添加一个切面，简单来讲，就是在直接返回数据前，对返回的结果包装一把；从实现也可以看出，主要的逻辑就在 AbstractJsonpResponseBodyAdvice 里面，所以有必要看一下这个东西是怎么支持的了 核心的代码逻辑就是 123456789101112131415161718192021222324@Overrideprotected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) &#123; HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest(); for (String name : this.jsonpQueryParamNames) &#123; String value = servletRequest.getParameter(name); if (value != null) &#123; if (!isValidJsonpQueryParam(value)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Ignoring invalid jsonp parameter value: \" + value); &#125; continue; &#125; // 下面三行是主要的逻辑 MediaType contentTypeToUse = getContentType(contentType, request, response); response.getHeaders().setContentType(contentTypeToUse); bodyContainer.setJsonpFunction(value); break; &#125; &#125;&#125; 直接看可能看不太明白究竟做了什么，写了个测试，debug下相关的参数如下 即，修改返回的 content-type 为： application/javascript 返回的Container里面设置了jsonpFunction，为请求参数的value，至于是在什么时候封装的返回结果呢？这个有待后续补全 II. 支持cors跨域 Cross-Origin Resource Sharing（CORS）跨来源资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求 1. 背景CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否 所以问题就来了，安全如何保证？ 一般而言，为了避免夸站点攻击(csrf)，常见的手段无非： 身份校验（比如要求用户登录） token验证 ip白名单 来源referer校验 频率限制 2. 实现方式要支持csrf，也比较简单了，无非就是设置下responseHeader了, 一般需要设置以下几项 Access-Control-Allow-Origin: *; // 允许的来源 Access-Control-Allow-Methods: GET, POST, PUT, DELETE Access-Control-Allow-Credentials: true Access-Control-Allow-Headers: Content-Type Access-Control-Max-Age: 1800 //30 min 所以实现起来的方式就比较多了，一个是新增一个filter，主动设置下返回头，当然spring mvc提供了更友好的方式了 常见的几种手段如下: a. xml配置方式12345&lt;mvc:cors&gt; &lt;mvc:mapping path=\"/ajax/*\" allowed-origins=\"*\" max-age=\"3600\" /&gt;&lt;/mvc:cors&gt; b. 注解方式在controller方法上，添加下面这个注解即可 12345@CrossOrigin(origins = \"*\")@RequestMapping(value = &#123;\"xx\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)public ResponseWrapper&lt;WxBaseResponse&gt; create(HttpServletRequest httpServletRequest) &#123;&#125; c. 直接修改返回的responseHeader123response.setHeader(\"Access-Control-Allow-Origin\", request.getHeader(\"origin\"));response.setHeader(\"Access-Control-Allow-Methods\", \"*\");response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); III. 小结上面介绍了两种方式，支持起来都比较简单 jsonp: 通过ControllerAdvice拦截Controller，然后继承AbstractJsonpResponseBodyAdvice即可 cors: 通过xml配置或者直接使用 @CrossOrigin注解 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Jsonp","slug":"Jsonp","permalink":"https://zbang.online/hexblog/tags/Jsonp/"},{"name":"CORS","slug":"CORS","permalink":"https://zbang.online/hexblog/tags/CORS/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}]},{"title":"SpringMVC返回图片的几种方式","slug":"SpringMVC返回图片的几种方式","date":"2018-01-18T03:13:22.000Z","updated":"2018-01-18T03:24:32.127Z","comments":true,"path":"2018/01/18/SpringMVC返回图片的几种方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/18/SpringMVC返回图片的几种方式/","excerpt":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？","text":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？ I. 返回二进制图片主要借助的是 HttpServletResponse这个对象，实现case如下 1234567891011121314@RequestMapping(value = &#123;\"/img/render\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@CrossOrigin(origins = \"*\")@ResponseBodypublic String execute(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123; // img为图片的二进制流 byte[] img = xxx; httpServletResponse.setContentType(\"image/png\"); OutputStream os = httpServletResponse.getOutputStream(); os.write(img); os.flush(); os.close(); return \"success\";&#125; 注意事项 注意ContentType定义了图片类型 将二进制写入 httpServletResponse#getOutputStream 写完之后，flush(), close()请务必执行一次 II. 返回图片的几种方式封装一般来说，一个后端提供的服务接口，往往是返回json数据的居多，前面提到了直接返回图片的场景，那么常见的返回图片有哪些方式呢？ 返回图片的http地址 返回base64格式的图片 直接返回二进制的图片 其他…（我就见过上面三种，别的还真不知道） 那么我们提供的一个Controller，应该如何同时支持上面这三种使用姿势呢？ 1. bean定义因为有几种不同的返回方式，至于该选择哪一个，当然是由前端来指定了，所以，可以定义一个请求参数的bean对象 123456789101112131415161718192021222324252627282930@Datapublic class BaseRequest &#123; private static final long serialVersionUID = 1146303518394712013L; /** * 输出图片方式: * * url : http地址 （默认方式） * base64 : base64编码 * stream : 直接返回图片 * */ private String outType; /** * 返回图片的类型 * jpg | png | webp | gif */ private String mediaType; public ReturnTypeEnum returnType() &#123; return ReturnTypeEnum.getEnum(outType); &#125; public MediaTypeEnum mediaType() &#123; return MediaTypeEnum.getEnum(mediaType); &#125;&#125; 为了简化判断，定义了两个注解，一个ReturnTypeEnum, 一个 MediaTypeEnum， 当然必要性不是特别大，下面是两者的定义 12345678910111213141516171819202122232425262728293031public enum ReturnTypeEnum &#123; URL(\"url\"), STREAM(\"stream\"), BASE64(\"base\"); private String type; ReturnTypeEnum(String type) &#123; this.type = type; &#125; private static Map&lt;String, ReturnTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(3); for(ReturnTypeEnum e: ReturnTypeEnum.values()) &#123; map.put(e.type, e); &#125; &#125; public static ReturnTypeEnum getEnum(String type) &#123; if (type == null) &#123; return URL; &#125; ReturnTypeEnum e = map.get(type.toLowerCase()); return e == null ? URL : e; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637@Datapublic enum MediaTypeEnum &#123; ImageJpg(\"jpg\", \"image/jpeg\", \"FFD8FF\"), ImageGif(\"gif\", \"image/gif\", \"47494638\"), ImagePng(\"png\", \"image/png\", \"89504E47\"), ImageWebp(\"webp\", \"image/webp\", \"52494646\"), private final String ext; private final String mime; private final String magic; MediaTypeEnum(String ext, String mime, String magic) &#123; this.ext = ext; this.mime = mime; this.magic = magic; &#125; private static Map&lt;String, MediaTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(4); for (MediaTypeEnum e: values()) &#123; map.put(e.getExt(), e); &#125; &#125; public static MediaTypeEnum getEnum(String type) &#123; if (type == null) &#123; return ImageJpg; &#125; MediaTypeEnum e = map.get(type.toLowerCase()); return e == null ? ImageJpg : e; &#125;&#125; 上面是请求参数封装的bean，返回当然也有一个对应的bean 1234567891011121314151617181920@Datapublic class BaseResponse &#123; /** * 返回图片的相对路径 */ private String path; /** * 返回图片的https格式 */ private String url; /** * base64格式的图片 */ private String base;&#125; 说明： 实际的项目环境中，请求参数和返回肯定不会像上面这么简单，所以可以通过继承上面的bean或者自己定义对应的格式来实现 2. 返回的封装方式既然目标明确，封装可算是这个里面最清晰的一个步骤了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void buildResponse(BaseRequest request, BaseResponse response, byte[] bytes) throws SelfError &#123; switch (request.returnType()) &#123; case URL: upload(bytes, response); break; case BASE64: base64(bytes, response); break; case STREAM: stream(bytes, request); &#125;&#125;private void upload(byte[] bytes, BaseResponse response) throws SelfError &#123; try &#123; // 上传到图片服务器，根据各自的实际情况进行替换 String path = UploadUtil.upload(bytes); if (StringUtils.isBlank(path)) &#123; // 上传失败 throw new InternalError(null); &#125; response.setPath(path); response.setUrl(CdnUtil.img(path)); &#125; catch (IOException e) &#123; // cdn异常 log.error(\"upload to cdn error! e:&#123;&#125;\", e); throw new CDNUploadError(e.getMessage()); &#125;&#125;// 返回base64private void base64(byte[] bytes, BaseResponse response) &#123; String base = Base64.getEncoder().encodeToString(bytes); response.setBase(base);&#125;// 返回二进制图片private void stream(byte[] bytes, BaseRequest request) throws SelfError &#123; try &#123; MediaTypeEnum mediaType = request.mediaType(); HttpServletResponse servletResponse = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse(); servletResponse.setContentType(mediaType.getMime()); OutputStream os = servletResponse.getOutputStream(); os.write(bytes); os.flush(); os.close(); &#125; catch (Exception e) &#123; log.error(\"general return stream img error! req: &#123;&#125;, e:&#123;&#125;\", request, e); if (StringUtils.isNotBlank(e.getMessage())) &#123; throw new InternalError(e.getMessage()); &#125; else &#123; throw new InternalError(null); &#125; &#125;&#125; 说明： 请无视上面的几个自定义异常方式，需要使用时，完全可以干掉这些自定义异常即可；这里简单说一下，为什么会在实际项目中使用这种自定义异常的方式，主要是有以下几个优点 配合全局异常捕获(ControllerAdvie)，使用起来非常方便简单 所有的异常集中处理，方便信息统计和报警 1如，在统一的地方进行异常计数，然后超过某个阀值之后，报警给负责人，这样就不需要在每个出现异常case的地方来主动埋点了 避免错误状态码的层层传递 12- 这个主要针对web服务，一般是在返回的json串中，会包含对应的错误状态码，错误信息- 而异常case是可能出现在任何地方的，为了保持这个异常信息，要么将这些数据层层传递到controller；要么就是存在ThreadLocal中；显然这两种方式都没有抛异常的使用方便 有优点当然就有缺点了： 异常方式，额外的性能开销，所以在自定义异常中，我都覆盖了下面这个方法，不要完整的堆栈 1234@Overridepublic synchronized Throwable fillInStackTrace() &#123; return this;&#125; 编码习惯问题，有些人可能就非常不喜欢这种使用方式 III. 项目相关只说不练好像没什么意思，上面的这个设计，完全体现在了我一直维护的开源项目 Quick-Media中，当然实际和上面有一些不同，毕竟与业务相关较大，有兴趣的可以参考 QuickMedia: https://github.com/liuyueyi/quick-media : BaseAction: com.hust.hui.quickmedia.web.wxapi.WxBaseAction#buildReturn IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Response","slug":"Response","permalink":"https://zbang.online/hexblog/tags/Response/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}]},{"title":"2017年全年回顾小结","slug":"2017年全年回顾小结","date":"2018-01-17T12:23:52.000Z","updated":"2018-01-17T12:35:08.800Z","comments":true,"path":"2018/01/17/2017年全年回顾小结/","link":"","permalink":"https://zbang.online/hexblog/2018/01/17/2017年全年回顾小结/","excerpt":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。","text":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。 15年开始工作，17年呢，不再是职场新人，但是说到老鸟，却也相差甚远，工作的第二个年度，总感觉有些不温不火的，仔细看看这一年，尝试了很多东西，也做了一些事情，但总的来说，依然是达不到预期。 一个比较好的坚持下去的习惯就是每周一次的锻炼，虽然是因为小团队内的要求，不达标就罚款的前提定在这，所以努力的坚持了下来，还是值得表扬的。唯一和预期不一致的就是锻炼的效果好像不太明显，比去去年，体重确实又增加了不少。从工作来，体重可算是算着工作时长线性增加，有点可怕，感觉再这么下去，就没法玩了。坚持锻炼，努力运动，健康生活，依然是18年需要去维持的事情；此外也有必要，增加下运动的类型，除了跑步、骑车，还有那么多可以去尝试的活动，有必要去探索一下。 17年，与之前那么多年，最不同的有两件事，一个是入了王者荣耀的坑、变成了一个手游爱好者；还有一个就是写博客，每周最少一篇博文。然后这一年的常态就变成了每天晚上抱着手机玩游戏，每个周末跑到公司吭哧吭哧的写博文（当然有不少时候是为了写而写，所以有些内容比较难入眼）。这两件事情，则有必要好好的谈一下了。 首先是玩游戏这个，之前不怎么玩，挺浪费时间的，而且也没有什么特别有意思的，不知道什么时候开始接触农药，期间卸载了又重装了n次，现在水平依然很烂，仔细想了想自己，对于玩游戏有个奇怪的地方，不愿意去研究，到现在玩耍了大半年，依然不知道装备怎么出，不知道铭文怎么组合，反正都是随意玩，不管什么场景，顺风逆风，都是那么一套玩法，玩来玩去也就是那一个英雄（芈月）；一起玩的小伙伴已经荣升星曜，而我依然在黄金白银徘徊，简直了。其实从这个玩游戏的状态中也可以看出，我属于那种一旦熟悉了某种事务之后，不太愿意去更改、去变动的性格（总是玩一个英雄），主动专研能力不够（不看教程，不看视频…），脾气还不错（被坑了也不骂人）,还有就是定力不足（多次卸载游戏又重装）; (再次不得不说一句，感谢温柔漂亮的美人姣，非常理性的对待我玩游戏这一点） 另一个就是写博文了，这一年的写作，感觉比我上大学之后写的东西都要多了，差不多有八九十篇的样子了，之前抽空整理了个gitbook，挂在了私人服务器上: 小灰灰博文Book。写博文的收获其实挺大的，很多时候对于一个知识点，如果不尝试着去像其他人分享，你都不知道你到底掌握到什么程度了。而且如何才能写出一个漂亮的博文，真的没那么简单，这一年看了不少，有见过写的特别漂亮的，也看过写的不知道什么鬼的东西，当然现在我自己水平也不怎么样，但对比下前后的质量，发现还是有长进的。很多东西写着写着，会忽然发现一些平时没有注意的点。在这一块，感觉最主要的就是勤于总结，善于思考了。18年，这个坚持还是得继续下去的。因为写博文，当然为了避免玩单机，开通了头条号和公众号, 下面是链接，欢迎关注 谈到公众号，就有必要说一下与之相关的小程序了，小程序大火的时候，也进来玩了一下，做了两个，一个是《古诗选》，每天会推送十条古诗，而且可以根据关键词搜索相关古诗的小程序，感觉还蛮有意思的，结果等做完之后，告诉类目不对个人开放，简直了…；然后开始做第二个了，这个纯粹是为了实例验证我之前推的一个开源项目Quick-Media，主要提供图片、二维码、音视频处理服务，目前处于非常简陋的状态，通过写着两个小程序，最大的一个感受是，对于布局和样式这一块，实在是太不敏感了。 既然说到了开源项目，那也有必要提一下了，17年的一个收获就是做了几个有意思的开源项目，虽然不怎么成功，没什么人关注，但对个人的学习和收获还是很不错的。比如 提供SPI服务的Quick-Spi:https://github.com/liuyueyi/quick-spi，通过这个项目的实现，算是理解了spi到底是个什么东西，又可以怎么去玩； Quick-Crawle爬虫框架:https://github.com/liuyueyi/quick-crawler，很久很久以前就对爬虫感兴趣了，然后就从0到1构建了一个非常简单的爬虫框架，前面说的《古诗选》的内容，就是通过这个爬虫框架从网上爬下来的，从玩票的性质来看，还不错； Quick-Media多媒体服务:https://github.com/liuyueyi/quick-media，目前算是个人最多star的项目了，里面深度的刨析了一下二维码的生成，完全可以替换二维码上各种元素，当然还有一些其他的东西，这个项目算是工作的附属品，因为实际的工作中，很多服务都是不需要的，但是偶尔我个人会对某一块比较感兴趣，所以干脆新搞了一个，把自己平时的各种想法都丢上去尝试一下； quick-doraemon，一个基于redis实现的配置中心框架:https://github.com/liuyueyi/quick-doraemon，了解阿里的Diaemond的同学大概可以猜到这个是干嘛的，做这个，纯粹是为了探究一下一个配置中心的实现，到底需要些什么东西，最关键的是，这个实现简不简单； 另外还有两个小工具包，一个是基于PopClip的 https://github.com/liuyueyi/PopClip， 一个基于Alfred的小工具集合（目前没有对外开放，主要扔在了公司内网，有较多的内部信息） 出去跑了个步，都接不下来上面写的东西了，干脆直接换个话题，谈谈生活。然而仔细想了想，好像没啥好说的，基本上就是上班，晚上加班，回家睡觉，第二天继续上班；这日子，过得有点单调啊。自勉，18年不能这么下去了，好歹也得有点业务生活，出去逛逛圈，到处走走也好过每天死宅 17年，家庭新增了两个成员，不到一岁的小朋友，老大已经会走路了，而老二则处于只晓得吃吃喝喝的状态；小外甥的成就已经远远超过他们老舅我的状态了，听我妈说两岁多我都还不会走路，也是尴尬; 多了小朋友之后，还挺不错的，最近没什么事情就喜欢在淘宝，京东上看一些小朋友的玩具，各种积木，玩具车之类的，发现还蛮有意思的，小时候没有玩过的东西，完全可以借着小朋友的名头买来自己耍，也是不错；一直都不太喜欢小孩子，总觉得难以沟通，还挺麻烦，但看着老爸老妈，每天教他们的大外甥一些东西的时候，还是蛮有趣的，陪伴与成长，如果可以的话，父母还是需要和小孩子一起 17年花了所有的积蓄，借了一些，方才勉强凑够首付，贷款了个小破房，生活艰辛，唉，啥时候房价才能平民，千年前的“安得广厦千万间，大庇天下寒士俱欢颜”放在现在，依然有效；脑子不够灵活，只能拿点死工资，得开拓下自己的思路了。 感谢@美人姣的这一路的相伴，虽然生活过得比较平淡，没有那么多的惊喜，没有那么多的浪漫，这些主要都是我的原因了，得改正，该有的小惊喜还是得有的，拓宽一下思路，改变一下习性，让生活变得有意思起来，这个需要在18年好好培养。 最后，再憧憬下18年，定个小目标，该结婚过小日子了!!! @美人姣","categories":[{"name":"随笔","slug":"随笔","permalink":"https://zbang.online/hexblog/categories/随笔/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://zbang.online/hexblog/tags/日记/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://zbang.online/hexblog/categories/随笔/"}]},{"title":"基于OkHttp封装一个简单易用的http工具","slug":"基于OkHttp封装一个简单易用的http工具","date":"2018-01-15T05:15:03.000Z","updated":"2018-02-13T03:21:17.020Z","comments":true,"path":"2018/01/15/基于OkHttp封装一个简单易用的http工具/","link":"","permalink":"https://zbang.online/hexblog/2018/01/15/基于OkHttp封装一个简单易用的http工具/","excerpt":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析","text":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析 I. 封装后测试效果一览基本上，最常见的http交互有两个，一个get请求，一个post请求，因此这里也就封装了这两种请求方式，并额外增加一个上传文件的功能，我们可以通过使用case，来看一下我们最终封装后的使用姿势 123456789101112131415161718192021222324252627282930313233343536// 简单的get请求@Testpublic void testGet() &#123; String url = \"https://zbang.online/wx/list\"; try &#123; okhttp3.Response res = HttpWrapper.of(url).get(); if (res.isSuccessful()) &#123; String ans = res.body().string(); System.out.println(\"ans : \" + ans); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; @Testpublic void testUpload() &#123; String url = \"https://zbang.online/wx/qrcode/encode\"; String path = \"/Users/yihui/Desktop/img/test.jpg\"; File file = new File(path); try &#123; Response res = HttpWrapper.of(url) .file(\"image\", file.getName(), \"image/jpeg\", file) .addParam(\"content\", \"http://www.baidu.com\") .addParam(\"size\", \"400\") .upload(); if (res.isSuccessful()) &#123; String str = res.body().string(); System.out.println(\"ans: \" + str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 上面给出的是一个上传文件的case，实现主要是借助了builder模式，可以很简单的传递个中参数和配置，最后获取返回的结果，这样设计的好处很明显： 使用简单 阅读方便 II. 封装实现接下来进入正题，如何封装这个工具类呢，一般而言，发起http请求，需要设置请求参数，设置请求头，所以builder内部的元素可以很清晰的定义了 首先是引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt;&lt;/dependency&gt; 当然由于整个使用都比较简单，下面就直接贴出封装后的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class HttpWrapper &#123; private static OkHttpClient client = new OkHttpClient(); private static final String DEFAULT_USER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\"; public static Builder of(String url) &#123; return new Builder(url); &#125; public static class Builder &#123; private String url; private Map&lt;String, String&gt; params; private List&lt;MultipartBody.Part&gt; uploadParts; Request.Builder reqBuilder; Builder(String url) &#123; this.url = url; params = new HashMap&lt;&gt;(); uploadParts = new ArrayList&lt;&gt;(); reqBuilder = new Request.Builder(); // 默认添加上user-agent addHeader(\"User-Agent\", DEFAULT_USER_AGENT); &#125; // 添加参数 public Builder addParam(String key, String value) &#123; params.put(key, value); return this; &#125; // 添加头 public Builder addHeader(String key, String value) &#123; reqBuilder.addHeader(key, value); return this; &#125; public Builder file(String key, String fileName, String fileMime, byte[] bytes) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), bytes)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, File file) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), file)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, InputStream stream) throws IOException &#123; int size = stream.available(); byte[] bytes = new byte[size]; stream.read(bytes); return file(key, fileName, fileMime, bytes); &#125; /** * 发送get请求 * * @return * @throws IOException */ public Response get() throws IOException &#123; StringBuilder urlBuilder = new StringBuilder(url); if (!params.isEmpty()) &#123; urlBuilder.append(\"?\").append(Joiner.on('&amp;').withKeyValueSeparator('=').join(params)); &#125; return client.newCall(reqBuilder.url(urlBuilder.toString()).build()).execute(); &#125; /** * post表单数据 * * @return */ public Response post() throws IOException &#123; // 创建表单 FormBody.Builder formBodyBuilder = new FormBody.Builder(); if (!params.isEmpty()) &#123; params.forEach(formBodyBuilder::add); &#125; return client.newCall(reqBuilder.url(url) .post(formBodyBuilder.build()) .build()) .execute(); &#125; /** * 文件上传 * * @return * @throws IOException */ public Response upload() throws IOException &#123; MultipartBody.Builder bodyBuilder = new MultipartBody.Builder() .setType(MultipartBody.FORM); uploadParts.forEach(bodyBuilder::addPart); // 添加参数 params.forEach(bodyBuilder::addFormDataPart); return client.newCall(reqBuilder.url(url) .post(bodyBuilder.build()) .build()) .execute(); &#125; &#125;&#125; 针对上面的实现，有几个需要注意的地方 get请求时，将参数拼装到url上（需要考虑是否要编码？） post请求时，主要借助 FormBody 来存储请求参数 文件上传时， 主要利用Part来封装上传的文件，借助 MultipartBody来包装Part和请求参数 上传文件，需要指定其 MIME（即 Content-Type, 如 image/jpeg, audio/mp3, file/txt等） 传文件的同时，也可以传递post参数，当然url参数也是可以的 III. 测试验证前面给出的是一个传文件的case，下面则给出一个提交post表单的测试用例 这个http接口主要功能是实现markdown输出图片 12345678910111213141516171819202122232425262728293031323334@Testpublic void testPost() &#123; String url = \"https://zbang.online/wx/md2img\"; String content = \"h1 header\\n\" + \"============\\n\" + \"\\n\" + \"Paragraphs are separated by a blank line.\\n\" + \"\\n\" + \"2nd paragraph. *Italic*, **bold**, and `monospace`. Itemized lists\\n\" + \"look like:\\n\" + \"\\n\" + \" * this one\\n\" + \" * that one\\n\" + \" * the other one\"; String token = \"0xdahdljk3u8eqhrjqwer90e\"; String noborder = \"true\"; try &#123; Response res = HttpWrapper.of(url) .addParam(\"content\", content) .addParam(\"token\", token) .addParam(\"noborder\", noborder) .addParam(\"type\", \"stream\") .post(); if (res.isSuccessful()) &#123; BufferedImage bf = ImageIO.read(res.body().byteStream()); System.out.println(\"over\"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 测试演示 V. 其他源码相关源码可以参见： HttpWrapper.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Tool","slug":"Java/Tool","permalink":"https://zbang.online/hexblog/categories/Java/Tool/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Okhttp","slug":"Okhttp","permalink":"https://zbang.online/hexblog/tags/Okhttp/"},{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Tool","slug":"Java/Tool","permalink":"https://zbang.online/hexblog/categories/Java/Tool/"}]},{"title":"Redis实现分布式锁相关注意事项","slug":"Redis实现分布式锁相关注意事项","date":"2018-01-14T08:12:29.000Z","updated":"2018-02-13T03:21:17.018Z","comments":true,"path":"2018/01/14/Redis实现分布式锁相关注意事项/","link":"","permalink":"https://zbang.online/hexblog/2018/01/14/Redis实现分布式锁相关注意事项/","excerpt":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题","text":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题 I. 背景知识借助redis来实现分布式锁（我们先考虑单机redis的模式），首先有必要了解下以下几点： 单线程模式 setnx : 当不存在时，设置value，并返回1； 否则返回0 getset : 设置并获取原来的值 expire : 设置失效时间 get : 获取对应的值 del : 删除 ttl : 获取key对应的剩余时间，若key没有设置过超时时间，或者压根没有这个key则返回负数（可能是-1，-2） watch/unwatch : 事务相关 II. 方案设计1. 设计思路获取锁： 调用 setnx 尝试获取锁，如果设置成功，表示获取到了锁 设置失败，此时需要判断锁是否过期 未过期，则表示获取失败；循环等待，并再次尝试获取锁 已过期，getset再次设置锁，判断是否获取了锁（根据返回的值进行判断，后面给出具体的方案） 若失败，则重新进入获取锁的逻辑 释放锁： 一个原则就是确保每个业务方释放的是自己的锁 2. getset的实现方案网上一种常见的case，主要思路如下 setnx 尝试获取锁 失败，则 get 获取锁的value （一般是 uuid_timstamp） 判断是否过期，若没有过期，则表示真的获取失败 若过期，则采用 getset设置，尝试获取锁 实现代码如下 12345678910111213141516171819202122232425262728293031323334353637383940public class DistributeLock &#123; private static final Long OUT_TIME = 30L; public String tryLock(Jedis jedis, String key) &#123; while (true) &#123; String value = UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; String getsetOldVal = jedis.getSet(key, value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 jedis.set(key, getsetOldVal); &#125; &#125; &#125; public void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); &#125; &#125;&#125; 观察获取锁的逻辑，特别是获取超时锁的逻辑，很容易想到有一个问题 getSet 方法会不会导致写数据混乱的问题，简单来说就是多个线程同时判断锁超时时，执行 getSet设置锁时，最终获取锁的线程，能否保证和redis中的锁的value相同 上面的实现方式，一个混乱的case如下: 三个线程a,b,c 都进入到了锁超时的阶段 线程a, 获取原始值 oldVal, 并设置 t1 线程b, 获取线程a设置的 t1, 并重设为 t2 线程c, 获取线程b设置的 t2, 并重设为 t3 线程a，判断，并正式获取到锁 线程b，判断失败，恢复原来锁的内容为t1 线程c, 判断失败，恢复原来锁的内容为t2 问题出现了，获取锁的线程a，期望所得内容为t1, 但是实际为t2; 导致无法释放锁 实际验证 在上面的代码中，配合测试case，加上一些日志输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static String tryLock(Jedis jedis, String key) throws InterruptedException &#123; String threadName = Thread.currentThread().getName(); while (true) &#123; String value = threadName + \"_\" + UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; // 强制使所有的线程都可以到这一步 Thread.sleep(50); System.out.println(threadName + \" in getSet!\"); // 人工接入，确保t1 获取到锁， t2 获取的是t1设置的内容， t3获取的是t2设置的内容 if (\"t2\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(20); &#125; else if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; String getsetOldVal = jedis.getSet(key, value); System.out.println(threadName + \" set redis value: \" + value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 System.out.println(threadName + \" get lock!\"); if (\"t1\".equalsIgnoreCase(threadName)) &#123; // t1获取到锁，强制sleep40ms， 确保线t2,t3也进入了 getSet逻辑 Thread.sleep(40); &#125; return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 // 人肉介入，确保t2优先执行，并设置回t1设置的值, t3后执行设置的是t2设置的值 if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; else if (\"t2\".equalsIgnoreCase(threadName))&#123; Thread.sleep(20); &#125; jedis.set(key, getsetOldVal); System.out.println(threadName + \" recover redis value: \" + getsetOldVal); &#125; &#125;&#125; 测试case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void testLock() throws InterruptedException &#123; // 先无视获取jedis的方式 JedisPool jedisPool = cacheWrapper.getJedisPool(0); Jedis jedis = jedisPool.getResource(); String lockKey = \"lock_test\"; String old = DistributeLock.tryLock(jedis, lockKey); System.out.println(\"old lock: \" + old); // 确保锁超时 Thread.sleep(40); // 创建三个线程 Thread t1 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t1 &gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t2 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t2\"); Thread t3 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t3 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t3\"); t1.start(); t2.start(); t3.start(); Thread.sleep(10000);&#125;; 部分输出结果: 1234567891011121314main in getSet!main set redis value: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130main get lock!old lock: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130t1 in getSet!t2 in getSet!t1 set redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t1 get lock!t3 in getSet!t2 set redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t3 set redis value: t3_9aa5d755-43b2-43bd-9a0b-2bad13fa31f6_1515643763345t2 recover redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t3 recover redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341 重点关注 t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341，表示t1线程过去了锁，但是锁的内容不是其value，即便t2去恢复，也会被t3给覆盖 如何解决上面这个问题呢？ 上面是典型的并发导致的问题，当然可以考虑从解决并发问题的角度出发来考虑，一个常见的方式就是加锁了，思路如下：（不详细展开了） 在判断超时之后，加锁 再次获取对应的值，判断是否超时，是则执行上面的操作 否则退出逻辑，继续循环 这种实现方式，会有以下的问题： getset 这个方法执行，可能导致写入脏数据 基于服务器时钟进行超时判断，要求所有服务器始终一致，否则有坑 3. expire实现方式相比于前面一种直接将value设置为时间戳，然后来比对的方法，这里则直接借助redis本身的expire方式来实现超时设置，主要实现逻辑相差无几 123456789101112131415161718192021222324252627282930313233public class DistributeExpireLock &#123; private static final Integer OUT_TIME = 3; public static String tryLock(Jedis jedis, String key) &#123; String value = UUID.randomUUID().toString(); while(true) &#123; Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 jedis.expire(key, OUT_TIME); // 主动设置超时时间为3s return value; &#125; // 获取失败，先确认下是否有设置国超是时间 // 防止锁的超时时间设置失效，导致一直竞争不到 if(jedis.ttl(key) &lt; 0) &#123; jedis.expire(key, OUT_TIME); &#125; &#125; &#125; public static void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); System.out.println(Thread.currentThread() +\" del lock success!\"); &#125; else &#123; System.out.println(Thread.currentThread() +\" del lock fail!\"); &#125; &#125;&#125; 获取锁的逻辑相比之前的，就简单很多了，接下来则需要简单的分析下，上面这种实现方式，会不会有坑呢？我们主要看一下获取锁失败的场景 如果获取锁失败 表示有其他的业务方已经获取到了锁 此时，只能等持有锁的业务方主动释放锁 判断锁是否设置了超时时间，若没有则加一个（防止设置超时时间失败导致问题） 从上面这个逻辑来看问题不大，但是有个问题，case ： 如某个业务方setnx获取到了锁，但是因为网络问题，过了很久才获取到返回，此时锁已经失效并被其他业务方获取到了，就会出现多个业务方同时持有锁的场景 III. 小结说明想基于redis实现一个相对靠谱的分布式锁，需要考虑的东西还是比较多的，而且这种锁并不太适用于业务要求特别严格的地方，如 一个线程持有锁时，如果发生gc，导致锁超时失效，但是自己又不知道，此时就会出现多个业务方同时持有锁的场景 对于锁超时的场景，需要仔细考虑，是否会出现并发问题 确保只能释放自己的锁（以防止释放了别人的锁，出现问题） 参考链接 基于Redis的分布式锁到底安全吗? 利用redis实现的分布式锁 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zbang.online/hexblog/categories/Redis/"}],"tags":[{"name":"distributeLock","slug":"distributeLock","permalink":"https://zbang.online/hexblog/tags/distributeLock/"},{"name":"Redis","slug":"Redis","permalink":"https://zbang.online/hexblog/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://zbang.online/hexblog/categories/Redis/"}]},{"title":"SpringMVC之请求参数的获取方式","slug":"SpringMVC之请求参数的获取方式","date":"2018-01-04T08:48:39.000Z","updated":"2018-01-04T09:06:22.615Z","comments":true,"path":"2018/01/04/SpringMVC之请求参数的获取方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/04/SpringMVC之请求参数的获取方式/","excerpt":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE","text":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE I. GET请求参数获取get请求参数，一般都是直接挂在请求的url上，所以获取这些参数还是比较简单的 1. 通过 HttpServletRequest获取参数这个可以说是最基本最常见的的方式了，javax.servlet.ServletRequest#getParameter 来获取对应的参数，下面各处一个实例 1234567891011@RestController@RequestMapping(path = \"webs/demo\")public class DemoController &#123; @RequestMapping(path = \"req1\") public String req1(HttpServletRequest request) &#123; String user = request.getParameter(\"user\"); String password = request.getParameter(\"password\"); return \"req1 user: \" + user + \" pwd: \" + password; &#125;&#125; 根据上面暴露的接口，我们测试的case就很简单了 12345http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog&amp;password=123456## 输出 req1 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog## 输出 req1 user: 小灰灰Blog pwd: null 说明 这是一个最基本的获取参数的方式，get，post请求都适用的，通常在filter,intercepter中也是可以通过HttpServletRequest对象来获取请求参数 除了获取常见的请求参数之外，HttpServletRequest可以获取请求头的完整信息 在一次请求的生命周期内，可以通过下面的方式获取Request对象(当然也可以获取response对象) 12HttpServletRequest httpServletRequest = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); 2. 直接方法参数获取直接给出case, 这个方法依然是放在上面的DemoController下面的 1234@RequestMapping(path = \"req2\")public String req2(String user, String password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 请求验证 12345678910http://127.0.0.1:8080/webs/demo/req2?user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog&amp;password=123456## 输出： req2 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456## 输出： req2 user: null pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;User=blog## 输出： req2 user: null pwd: 123456 注意： 上面这种使用方式，相当于直接将url参数映射到了Controller方法的参数上了 方法参数名必须和url参数名完全一致（区分大小写） 顺序无关 若参数没传，则默认为null 一个疑问 上面的demo中Controller的方法参数都是String还好，如果将password改成int，会出现什么情况 代码稍作修改 1234@RequestMapping(path = \"req2\")public String req2(String user, int password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 实际测试 12345678910111213# case1 http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;user=blog## 输出： req2 user: blog pwd: 123456# case 2http://127.0.0.1:8080/webs/demo/req2?password2=123456&amp;user=blog## 输出: 报错, Optional int parameter 'password' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type# case 3http://127.0.0.1:8080/webs/demo/req2?password=abc&amp;user=blog## 输出：报错, \"Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"abc\"\" 结果说明 如果请求参数与方法参数类型不一致，会抛出转换异常 如果方法参数为非封装基本类型，则url参数必须存在，否则报错 3. RequestParam注解方式获取请求参数通过@RequestParam注解获取参数的方式和上面的一种比较类似，case如下 12345@RequestMapping(path = \"req3\", method = RequestMethod.GET)public String req3(@RequestParam(\"user\") String username, @RequestParam(\"password\") String pwd) &#123; return \"req3 user: \" + username + \" pwd: \" + pwd;&#125; 测试case 12345678# case1 http://127.0.0.1:8080/webs/demo/req3?password=123456&amp;user=blog## 输出: req3 user: blog pwd: 123456# case2http://127.0.0.1:8080/webs/demo/req3?password=123456## 输出：报错， Required String parameter 'user' is not presen 说明 不指定注解的name或value属性时，等同于第二种使用姿势 注解的name属性或value属性，用实际的参数名来指定 controller的参数名与url参数名没有强关联（区别第二种方式） 参数类型需要保证一致（通第二种方式） 如果url参数可选，请设置require属性为false，如下1@RequestParam(name = \"user\", required = false) String username 4. Bean方式获取参数对于请求参数比较复杂的情况下，我比较喜欢这种使用姿势，管理起来方便简单 12345678910@Datapublic static class UserDO &#123; String user; String password;&#125;@RequestMapping(path = \"req4\", method = RequestMethod.GET)public String req4(UserDO userDO) &#123; return \"req4 userDO: \" + userDO;&#125; 测试case 12345678# case1http://127.0.0.1:8080/webs/demo/req4?password=123456&amp;user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog## 输出: req4 userDO: DemoController.UserDO(user=小灰灰Blog, password=123456)# case2http://127.0.0.1:8080/webs/demo/req4?password=123456## 输出: req4 userDO: DemoController.UserDO(user=null, password=123456) 说明 定义一个bean，内部属性和请求参数对应 允许参数不存在的情况，会使用null代替（所以，尽量不要使用非封装基本类型，否则参数不传时，会抛异常） bean的属性，可以根据实际情况指定类型 5. ModelAttribute注解方式@ModelAttribute注解的方法，会优于Controller之前执行，一般更常见于向视图传输数据使用，此处不详细展开，正常来讲，专门的获取参数不太会用这这种方式来玩 6. Path参数Path参数，专指的是请求路径的参数，如 1http://127.0.0.1:8080/webs/demo/req4?password=123456 上面这个url中，password是我们传统意义上的请求参数，其中path参数则是指其中 req4, demo这种path路径中的一环；对此，最常见的一个case就是常见的博客中,如开源中国的一个博客链接 1https://my.oschina.net/u/566591/blog/1601400 566591 : 这个参数主要用来区分用户 1601400 : 这个参数则主要是表示对应的博文 一般path参数的获取方式如下 1234@RequestMapping(path = \"req6/&#123;user&#125;/info\")public String req6(@PathVariable(name = \"user\") String user) &#123; return \"req6 user: \" + user;&#125; 测试case 1234567891011# case1 http://127.0.0.1:8080/webs/demo/req6/blog/info?user=haha## 输出：req6 user: blog# case2http://127.0.0.1:8080/webs/demo/req6/blog?user=haha## 输出: 404# case3http://127.0.0.1:8080/webs/demo/req6/info?user=haha## 输出: 404 注意: path参数的使用，需要确保参数存在且类型匹配 path参数和url参数不会相互影响 II. POST请求参数获取POST请求参数，更多的是看提交表单参数是否可以获取到，以及如何获取，主要的手段依然是上面几种方式，下面验证下是否ok 1. HttpServletRequest方式获取参数测试case，可以借助curl来实现post请求 123456789101112# case1 curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req1\"## 输出： req1 user: 小灰灰Blog pwd: 123456# case2curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?password=123456\"## 输出：req1 user: 小灰灰Blog pwd: 12345# case3curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?user=greyBlog\"## 输出：req1 user: greyBlog pwd: null curl也可以换成js请求测试方式 1234567891011var formData = new FormData();formData.append(\"user\", \"小灰灰Blog\");$.ajax(&#123; url: 'http://127.0.0.1:8080/webs/demo/req1?password=123456', type: 'post', cache: false, data: formData, processData: false, contentType: false&#125;); 说明 对于HttpServletReuqest方式获取参数时，get和post没什么区别 若url参数和表单参数同名了，测试结果显示使用的是url参数（待确认，当然最好不要这么干） 2. 方法参数获取几个测试demo如下 12345678910111213# case 1curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出： req2 user: 小灰灰Blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出：req2 user: null pwd: 123456# case 3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2?user=blog\"## 输出： req2 user: blog pwd: 123456 基本上使用姿势和get没什么区别 3. RequestParam注解方式12345678910111213# case 1curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3\"## 输出： req3 user: blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req3?user=blog\"## 输出： req3 user: blog pwd: 123456# case 3curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3?password=900\"## 输出：req3 user: blog pwd: 900,123456 注意 和前面的两种方式不同的是，当post表单的参数和url参数同名时，会合并成一个字符串 4. Bean方式12345678910111213## case1 curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4?password=900\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=900,123456)## case2curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=123456)## case3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=null, password=123456) 这种方式不区分get,post，所以完全复杂的交互接口，完全可以考虑用bean的方式来定义请求参数 5. PathVariable这个没法玩… III. 多媒体上传参数获取 上传文件的支持，对于传统的spring-mvc来说，可能需要一些添加一些相关配置，不在本文的范畴内，下面默认已经配置好 1. 实例支持1234567891011121314@RequestMapping(path = &#123;\"wx/upload\", \"wx/wx/upload\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@ResponseBodypublic String upload(HttpServletRequest request) &#123; MultipartFile file = null; if (request instanceof MultipartHttpServletRequest) &#123; file = ((MultipartHttpServletRequest) request).getFile(\"image\"); &#125; if (file == null) &#123; throw new IllegalArgumentException(\"图片不能为空!\"); &#125; return \"success\";&#125; 简单来说，主要是利用HttpServletRequest来获取上传的文件 注意： 如果接口必须要求上传文件，可以直接把参数声明为 MultipartHttpServletRequest， 此时调用方如果不传参数，会被异常拦截（可以通过@ControllerAdvice来拦截全局异常） 如果可以不上传文件，则可以用上面的这种猥琐姿势，内部进行判断 ((MultipartHttpServletRequest) request).getFile(xxx)来获取指定名的上传文件 IV. 小结1. 五种获取参数的姿势 方式 注意事项 HttpServletRequest获取参数 最常见通用 方法参数与请求参数同名 注意参数名统一，注意类型一致，尽量不用非包装基本类型 @RequestParam注解 同上，可注解内指定http参数名 Bean方式 定义一个bean，会将同名的http参数赋值进去，推荐 @PathVariable 注解 请求url参数 2. 传文件使用姿势使用MultipartHttpServletRequest来获取上传的文件，当然也可以获取基本的请求参数 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"RequestParam","slug":"RequestParam","permalink":"https://zbang.online/hexblog/tags/RequestParam/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zbang.online/hexblog/categories/Java/Spring/"}]},{"title":"jvm调优的工具介绍","slug":"jvm调优的工具介绍","date":"2018-01-03T06:18:35.000Z","updated":"2018-02-13T03:21:17.019Z","comments":true,"path":"2018/01/03/jvm调优的工具介绍/","link":"","permalink":"https://zbang.online/hexblog/2018/01/03/jvm调优的工具介绍/","excerpt":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能","text":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能 jvm相关参数记录 12-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+ExplicitGCInvokesConcurrent -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xxx/java.hprof -XX:InitialCodeCacheSize=134217728 -XX:InitialHeapSize=4294967296 -XX:MaxDirectMemorySize=1073741824 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=268435456 -XX:MaxNewSize=2147483648 -XX:MetaspaceSize=268435456 -XX:NewSize=2147483648 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ReservedCodeCacheSize=268435456 -XX:SurvivorRatio=10 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 2. 监控工具使用tsar作为服务器性能监控工具，所以前提是先安装tsar 12345wget -O tsar.zip https://github.com/alibaba/tsar/archive/master.zip --no-check-certificateunzip tsar.zipcd tsarmakemake install 监控命令 1tsar --cpu --swap -i1 -l 说明 tsar相关可以参考： Linux系统性能监控工具介绍之-tsar II. 相关知识点简介截取几条gc日志 1234562018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs]2018-01-02T10:49:25.374+0800: 13.999: [GC (Allocation Failure) 2018-01-02T10:49:25.374+0800: 13.999: [ParNew: 1881830K-&gt;93708K(1922432K), 0.0910714 secs] 1949062K-&gt;197949K(4019584K), 0.0911833 secs] [Times: user=0.26 sys=0.01, real=0.09 secs]2018-01-02T10:55:53.013+0800: 401.639: [GC (GCLocker Initiated GC) 2018-01-02T10:55:53.013+0800: 401.639: [ParNew: 1841429K-&gt;142552K(1922432K), 0.0629031 secs] 1945670K-&gt;246793K(4019584K), 0.0630512 secs] [Times: user=0.14 sys=0.01, real=0.06 secs]2018-01-02T10:55:55.076+0800: 403.701: [GC (GCLocker Initiated GC) 2018-01-02T10:55:55.076+0800: 403.701: [ParNew: 1890281K-&gt;59983K(1922432K), 0.0661778 secs] 1994522K-&gt;201875K(4019584K), 0.0663176 secs] [Times: user=0.15 sys=0.01, real=0.07 secs]2018-01-02T11:47:25.271+0800: 3493.897: [GC (Allocation Failure) 2018-01-02T11:47:25.271+0800: 3493.897: [ParNew: 1807695K-&gt;20975K(1922432K), 0.0193077 secs] 1949587K-&gt;162867K(4019584K), 0.0195351 secs] [Times: user=0.04 sys=0.00, real=0.02 secs]2018-01-02T11:56:50.621+0800: 4059.247: [GC (GCLocker Initiated GC) 2018-01-02T11:56:50.622+0800: 4059.247: [ParNew: 1774543K-&gt;108899K(1922432K), 0.0401606 secs] 1916434K-&gt;250791K(4019584K), 0.0403586 secs] [Times: user=0.10 sys=0.00, real=0.04 secs] 1. CMS GC日志格式分析截取上面日志中的第一条，分别说明每一项是什么意思 2018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs] 2018-01-02T10:49:20.390+0800 ：发生gc的时间 9.015 - GC开始，相对JVM启动的相对时间，单位是秒 GC - 区别FullGC和MinorGC的标识，此处表示为MinorGC (Allocation Failure) - 发生gc的原因，此处表示空间不足，导致分配失败 ParNew – 收集器的名称，它预示了年轻代使用一个并行的 mark-copy stop-the-world 垃圾收集器 1922431K-&gt;134118K – 收集前后年轻代的使用情况，未回收之前，大小为1922431K, 回收完毕之后，大小为134118K, 所以回收大小为: 1922431K - 134118K (1922432K) - 整个年轻代的容量 0.1486593 secs - 这个解释用原滋原味的解释：Duration for the collection w/o final cleanup. 1934749K-&gt;201350K - 收集前后整个堆的使用情况 (4019584K) - 整个堆的容量 0.1487460 secs – ParNew收集器标记和复制年轻代活着的对象所花费的时间（包括和老年代通信的开销、对象晋升到老年代时间、垃圾收集周期结束一些最后的清理对象等的花销）； [Times: user=0.78 sys=0.01, real=0.11 secs] – GC事件在不同维度的耗时，具体的用英文解释起来更加合理: user – Total CPU time that was consumed by Garbage Collector threads during this collection sys – Time spent in OS calls or waiting for system event real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by the Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount. 2. CMS简介 后端服务选用的就是CMS，那么就有必要看一下这个CMS到底是个什么东西 CMSConcurrent Mark Sweep 收集器，是一种以获取最短回收停顿时间为目标的收集器，核心就是标签-清除算法 步骤划分 初始标记 (CMS initial mark) : 标记GC Roots能直接关联到的对象，速度很快，会暂停 并发标记 (CMS concurrent mark) : 进行 GC Roots Tracing的过程 重新标记 (CMS remark) : 为了修正并发标记期间，因为程序继续运作导致标记变动的那一部分对象的标记记录，一般会长于初始标记时间，远小于并发标记的时间 并发清除 (CMS concurrent sweep) : 说明，初始标记和重新标记的时候，会暂停服务；后面两个则是并发修改 标记清除算法一句话描述： 标记所有需要回收的对象，在标记完成后，统一回收所有被标记的对象 常见的两个问题： 效率不高；回收后大量的碎片 3. 内存分配和回收策略a. 对象优先在Eden分配大多数场景下，对象在新生代Eden区分配，当Eden去没有足够的空间进行分配时，虚拟机发起一次 Minor GC 新生代MinorGC ： 发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性是，所以一般MinorGC非常频繁，一般回收速度也很快 老年代MajorGC(FullGC) : 发生在老年代的GC，通常就伴随至少一次的MinorGC（非绝对），一般较慢，是MinorGC的十倍以上 b. 大对象直接进入老年代需要大量连续内存空间的Java对象，通常是数组，同构 -XX:PretenuresizeThreshold 参数，来设置大对象的阀值，超过这个阀值的直接分配在年老代，避免在Eden区及两个Survivor区指尖发生大量的内存复制 c. 长期存活的对象将进入老年代既然虚拟机采用分代收集的思想来管理内存，在回收时，就必须能识别哪些对象应放在新生代，那些对象应放在老年代中 每个对象都有个Age的计数器，对象在Eden出生并经过第一次MinorGC后仍存在，且可以被Survivor容纳的话，会被移动到Survivor空间中，并设置Age为1 对象在Survivor区没多经过一次MinorGC，则age+1 当age超过阀值（默认15），就会晋升到老年代 阀值可以通过 -XX:MaxTenuringThreshold来设置 d. 动态对象年龄判定如果在Survivor空间中相同年龄所有对象的大小的总和，大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代，无序等Age达到阀值 e. 空间分配担保在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC可以确保总是安全的； 否则，查看 HandlePromotionFailure参数，是否允许担保失败 若允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试MinorGC 否则进行FullGC 3. jstat 命令简介 既然问题是频繁的gc引起的，那么观察新生代，老年代对象占用空间的情况就不可避免了，所以jstat命令不得不出现了 截一个线程图 1234567$ jstat -gcutil 11573 1000 5 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 34.39 24.68 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 26.29 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 27.45 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 28.32 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 29.93 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 a. 参数说明 -gcutil ： 监视Java对状况，包括Eden区、两个survivor区，老年代，永久代等，已用空间，gc时间等 11573： java进程号 1000： 每1s刷新一次 5： 一共查询5次 b. 输出说明 S0, S1: 表示两个 survivor区 E(Eden) : 新生代Eden O(Old) : 老年代Old M(metaspace) : 元空间,本地内存， 在1.8移除了永久代改成这个 YGC : 程序运行以来，发生Minor GC(Young GC)次数 YGCT : Minor GC 总耗时（单位s) FGC : Full GC的总次数 FGCT : Full GC的总耗时 （单位s) GCT : 所有GC的总耗时 （单位s) III. 监控测试0. 准备a. 首先是获取对应的进程号12jps -ljinfo xxx 抓图 123$ jps -l30916 sun.tools.jps.Jps2909 org.apache.catalina.startup.Bootstrap b. 服务器性能监控命令12## 主要查看cpu和nginx访问的监控tsar --cpu --nginx -i1 -l 抓图: 12345678Time -----------------------cpu---------------------- ----------------------------------nginx---------------------------------Time user sys wait hirq sirq util accept handle reqs active read write wait qps rt03/01/18-11:29:37 16.54 1.50 0.00 0.00 0.00 18.05 2.00 2.00 6.00 15.00 0.00 1.00 14.00 6.00 89.5003/01/18-11:29:38 26.07 1.75 0.00 0.00 0.00 27.82 3.00 3.00 10.00 15.00 0.00 1.00 14.00 10.00 47.1003/01/18-11:29:39 19.60 1.01 0.00 0.00 0.00 20.60 4.00 4.00 11.00 15.00 0.00 1.00 14.00 11.00 37.8203/01/18-11:29:40 28.75 2.50 0.00 0.00 0.25 31.50 2.00 2.00 10.00 15.00 0.00 1.00 14.00 10.00 79.3003/01/18-11:29:41 14.07 1.51 0.00 0.00 0.00 15.58 1.00 1.00 10.00 15.00 0.00 3.00 12.00 10.00 51.3003/01/18-11:29:42 20.60 1.01 0.00 0.00 0.00 21.61 6.00 6.00 13.00 15.00 0.00 1.00 14.00 13.00 44.69 c. jvm内存的监控1jstat -gcutil 4354 1000 抓图: 123456$ jstat -gcutil 2909 1000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 29.03 0.00 66.34 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.37 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.50 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.54 16.34 98.57 96.32 200 6.393 0 0.000 6.393 d. 查看内存中对象的个数和大小1jmap -histo 4354 抓图 123456789101112num #instances #bytes class name---------------------------------------------- 1: 78179 181546608 [I 2: 1259 175880312 [S 3: 35915 65527520 [B 4: 242125 40558408 [C 5: 571604 13718496 java.util.concurrent.atomic.AtomicLong 6: 233282 5598768 java.lang.String 7: 55177 5296992 java.util.jar.JarFile$JarFileEntry 8: 119906 3836992 java.util.HashMap$Node 9: 33327 2932776 java.lang.reflect.Method 10: 1147 2303216 [Ljava.util.concurrent.atomic.AtomicLong; e. 压测模拟工具Jmetter 添加线程组 新增http请求 添加监听器中，结果的监控：图形结果，聚合报告，查看结果树，用表格查看结果 http请求中配置参数 协议 域名or IP + 端口号 编码: utf-8 请求方法 + 请求路径 请求参数，支持文件上传，注意编码方式 IV. 参考 Linux系统性能监控工具介绍之-tsar tsar使用说明 JVM调优——之CMS GC日志分析 jvm的GC日志分析 JVM 运行时内存使用情况监控 《深入理解JVM虚拟机》 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://zbang.online/hexblog/categories/Java/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://zbang.online/hexblog/categories/Java/JVM/"}]},{"title":"JDK学习之反射的使用姿势一览","slug":"JDK学习之反射的使用姿势一览","date":"2017-12-29T12:26:51.000Z","updated":"2018-02-08T04:06:14.096Z","comments":true,"path":"2017/12/29/JDK学习之反射的使用姿势一览/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/JDK学习之反射的使用姿势一览/","excerpt":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景","text":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景 I. 反射定义 指程序可以访问、检测和修改它本身状态或行为的一种能力 直接说定义的话，可能并不能非常清晰的解释说明，结合作用进行描述 反射可以干什么？ 1234在运行时构造任意一个类的对象。在运行时判断任意一个对象所属的类。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法 有了上面四点，基本上你想干嘛就可以干嘛，比如我现在就有下面这个类 1234567891011121314151617181920212223242526272829public class RefectTest extends MyRefect implements IRefect &#123; private static String s1 = \"hello\"; private static int s2 = 100; private int s3 = 200; private boolean ans; protected RefectTest next; public RefectTest() &#123; &#125; public RefectTest(int s3, boolean ans, RefectTest next) &#123; this.s3 = s3; this.ans = ans; this.next = next; &#125; public RefectTest next() &#123; return next; &#125; private int count(int a, int b) &#123; return a + b; &#125;&#125; 现在我有了clz,其赋值语句为 Class clz = RefectTest.class， 那么我可以干啥？ 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 上面给出了可以干些什么，并给了对应的简单示例，引入了几个新的类Constructor, Field, Method， 下面将详细解释这三个类是什么，怎么用 II. 反射的使用努力结合实际的应用场景，给出每种利用反射的实现对应需求的使用姿势，有些场景可能并不是特别贴切，欢迎提出给合适的场景以此进行替换 1. 通过反射创建对象 这是个比较常见的场景，我在使用了自定义注解时，通常会这么晚 应用场景： 我定义了一个校验器的注解ValDot，注解中有个校验规则class对象，如下 1234567891011121314151617public interface ICheckRule &#123; boolean check(Object ... obj);&#125;public class DefaultCheckRule implements ICheckRule &#123; @Override public boolean check(Object... obj) &#123; return false; &#125;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CheckDot &#123; // 校验规则 Class&lt;? extends ICheckRule&gt; check() default DefaultCheckRule.class;&#125; 上面定义了注解和校验条件，接着进入整体，在切面中，需要获取 1234567891011121314@Aspect@Componentpublic class CheckAspect &#123; @Before(\"@annotation(checkDot)\") public void process(JoinPoint joinPoint, CheckDot checkDot) throws IllegalAccessException, InstantiationException &#123; // 注意，这里获取注解上的校验规则类，并获取实例 ICheckRule rule = checkDot.check().newInstance(); if(rule.check(joinPoint.getArgs())) &#123; throw new IllegalStateException(\"check argument error!\"); &#125; &#125;&#125; 上面是一个较好的利用反射获取实例的应用场景，想一想，如果不用反射，这个校验规则怎么传进来呢，这个时候就没那么方便了（当然也不是不可以，最简单的就是拿一个Holder持有类名到类对象的映射关系，然后在注解中传类名，也可以达到上面的效果） 还有一种场景可能就比较蛋疼了，如果一个类没有默认构造方法，通过反射就没法直接用class.newInstanace()了 Constructor构造器类 根据Class优先获取到 Constructor 对象，然后传入需要的构造参数, 测试如下 1234567891011121314151617181920212223public class ConTest &#123; private int a,b; public ConTest(int a, int b) &#123; this.a = a; this.b = b; &#125; @Override public String toString() &#123; return \"ConTest&#123;\" + \"a=\" + a + \", b=\" + b + '&#125;'; &#125; public static void main(String[] args) throws Exception &#123; Class clz = ConTest.class; // 获取对应的构造器（注意参数类型） Constructor constructor = clz.getConstructor(int.class, int.class); // 创建实例（注意参数要匹配） ConTest test = (ConTest) constructor.newInstance(10, 20); System.out.println(test.toString()); &#125;&#125; 输出 1ConTest&#123;a=10, b=20&#125; 一般常用下面四种方式获取 1234567891011// 根据参数类型获取匹配的构造器Constructor getConstructor(Class[] params)// 获取所有的Constructor[] getConstructors()// 相比较前面的，这里可以获取私有方法Constructor getDeclaredConstructor(Class[] params)// 可以获取私有方法Constructor[] getDeclaredConstructors() 2. 判断class的继承关系判断是否为基础数据类型基本类型较为特殊，所以JDK很人性化的给封装了一个方法，Class#isPrimitive 因此返回true的类型有: int long short byte char boolean 封装后的类型，返回的依然是false 附带一句，是没有null.class这种用法的 判断是否为另一个类的子类，另一个接口的实现类通常我们利用 instanceof 关键字来判断继承关系，但是这个是针对对象来的，现在给一个class，要怎么玩？ 看下面，主要就是 Class#isAssignableFrom() 的功劳了 1234567891011121314151617181920212223public class ExtendTest &#123; interface ITest &#123;&#125; abstract class ATest &#123; abstract public void print(); &#125; class TestClz extends ATest implements ITest &#123; @Override public void print() &#123; System.out.println(\"TestClz\"); &#125; &#125; public static void main(String[] args) &#123; Class clz = TestClz.class; System.out.println(ATest.class.isAssignableFrom(clz)); System.out.println(ITest.class.isAssignableFrom(clz)); &#125;&#125; 需要注意一点，父类作为调用方，子类作为参数 结合泛型时，获取泛型的实际类型泛型，又是一个有意思的功能，这里不多说，继承一个泛型基类，然后问题是如何通过反射获得泛型签名中的类型，一般会在继承或实现泛型接口时会用到它。 123456789class A&lt;T, ID&gt; &#123;&#125;class B extends A&lt;String, Integer&gt; &#123;&#125;public static void main(String[] args) &#123; System.out.println(B.class.getGenericSuperclass());&#125; 换成泛型接口呢 ? 12345678910111213interface A&lt;T, ID&gt; &#123; &#125; class B implements A&lt;String, Integer&gt; &#123; &#125;public static void main(String[] args) &#123; ParameterizedType parameterizedType = (ParameterizedType) B.class.getGenericInterfaces()[0]; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125;&#125; 3. 获取成员变量获取成员变量，主要是根据 B.class.getDeclaredFields() 来获取所有声明的变量，这个应用场景会和下面的获取方法并执行联合一起说明 1234567891011// 获取指定的公共成员变量Field getField(String name)// 获得所有公共字段Field[] getFields()// 获取指定声明的成员变量（包括prive）Field getDeclaredField(String name)// 获取所有声明的成员变量Field[] getDeclaredFields() 这个主要返回 Field对象，现在有了Field，可以做些啥？ 判断成员的修饰 Field#getModifiers() 12345678int modify = field.getModifiers();// 是否是静态变量boolean ans = Modifier.isStatic(modifier);// 是否是公共变量boolean ans = Modifier.isPublic(modifier);// 是否不可变boolean ans = Modifier.isFinal(modifier);// ... 获取成员的变量名 : field#getName() 获取成员对应的value: field#get(instance) 对于静态成员，instance可以为null 对于非静态成员，instance必须为一个实例对象 获取注解: field#getAnnotations() 这个就厉害了，hibernate的校验框架，在成员变量上加一个注解Max,就可以设置参数的最大值，其实就是通过反射获取到注解，然后进行相应的逻辑 4. 获取方法获取方法，同上面的差不多，也有四种方式 1234567891011// 根据方法名，参数类型获取公共方法Method getMethod(String name, Class[] params)// 获取所有的公共方法Method[] getMethods()// 根据方法名，参数类型，获取声明的方法（包括私有）Method getDeclaredMethod(String name, Class[] params)// 获取所有声明的方法Method[] getDeclaredMethods() 返回了一个Method类，那么这个东西又有一些什么功能？ 获取方法名 Method#getName() 获取方法所在的类 : Method#getDeclaringClass() 获取方法返回类型 : Method#getReturnType() 获取方法上的注解 : Method#getAnnotations() 执行方法 有了这个就可以做很多事情了，实例中给出说明 1234// 设置方法可访问（即私有方法也可以被调用）method.setAccessible(true);// instance为实例对象， args为传入参数method.invoke(instance, args) III. 实例DEMO通过反射的方式，实现一个 BeanUtils，实现Bean的拷贝 当一个Bean有较多的成员变量时，如果我们采用最原始的setXXX()来一次赋值的时候，一是实现比较繁琐，其次就是当Bean的字段发生变动之后，也需要同步的修改，那么我们借助反射的方式，实现一个优雅的 BeanUtils 工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BeanUtils &#123; public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125; &#125; private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; // 没有匹配到，这里返回null实际上是不合适的 // 因为如果原属性为基本数据类型，赋值null为报错 throw new Exception(); &#125;&#125; IV. 小结反射的四种用途 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 使用注意事项 操作私有变量，私有方法时，先设置field.setAccessible(true);确保可访问 反射会带来额外的性能开销 可以用 Class#isAssignableFrom() 来判断类继承关系 可以用 Class#isPrimitive()判断是否为基本数据类型 可以用 Class#getGenericSuperclass() 获取泛型类型 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"https://zbang.online/hexblog/tags/Reflect/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}]},{"title":"Centos 安装hexo博客","slug":"Centos-安装hexo博客","date":"2017-12-29T10:10:43.000Z","updated":"2018-02-13T03:21:17.017Z","comments":true,"path":"2017/12/29/Centos-安装hexo博客/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/Centos-安装hexo博客/","excerpt":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选","text":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选 安装步骤12345678910## 1. nodejs安装sudo yum install nodejs## 2. 安装 hexosudo npm install -g hexo-clisudo npm install## 3. 创建hexohexo init xxxnpm install 测试验证 hexo server 使用说明1. 创建一个page执行下面的命令之后，就可以创建一个menu菜单 1hexo new page about 2. 新建一个博文1hexo new 'new blog' 3. 显示简介在md文件中，某一个地方地方添加 1&lt;!-- more --&gt; 则后面的内容都不会显示在首页了 4. 启动12345## 编译hexo g## 启动一个serverhexo s 5. deploy打开 _config.yml 文件，添加配置 1234deploy: type: git repository: https://github.com/liuyueyi/blogs.git branch: master 开始发布: 1hexo d -g 说明 如果github上，访问网页时，提示js或者css 404，则需要注意下面的配置 1234567# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://liuyueyi.github.io/hexblogroot: /hexblog/permalink: :year/:month/:day/:title/permalink_defaults: lang: zh-cn 其中URL，和root是关键的设置属性，root最后的/不能漏掉 如果提示git没有，则需要安装 1npm install hexo-deployer-git --save","categories":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"环境搭建","slug":"Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/Shell/环境搭建/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zbang.online/hexblog/tags/Hexo/"}],"keywords":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"环境搭建","slug":"Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/Shell/环境搭建/"}]},{"title":"Nginx 路由转发配置笔记","slug":"Nginx-路由转发配置笔记","date":"2017-12-27T09:57:18.000Z","updated":"2018-02-13T03:21:17.018Z","comments":true,"path":"2017/12/27/Nginx-路由转发配置笔记/","link":"","permalink":"https://zbang.online/hexblog/2017/12/27/Nginx-路由转发配置笔记/","excerpt":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html）","text":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html） I. location匹配规则1. 语法123location [=|~|~*|^~|@] /uri/ &#123; ...&#125; 2. 说明从上面的语法出发，可以了解到location可以区分为三个部分，接下来一个一个的研究一下 a. PartOne: [=|~|~*|^~|@] = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 上面定义了几个不同的符号，表示不同的匹配规则，那么先后顺序呢？ =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 直接看这个可能不太好理解，写几个case实际测试一下 测试case1: 123456789101112131415location = /world &#123; return 600;&#125;location = /hello &#123; return 600;&#125;location ~ /hellowo &#123; return 602;&#125;location ^~ /hello &#123; return 601;&#125; 12345678- 请求 localhost/world 返回600- 请求 localhost/world2 localhost/test/world 返回其他- 请求 localhost/hello 返回600- 请求 localhost/hello/123 返回601- 请求 localhost/hellow 返回601- 请求 localhost/hellowo 返回601- 请求 localhost/test/hellowo 返回602- 请求 localhost/test/hello 返回其他 因此可以知道 = 是精确完整匹配, 且优秀最高 正则匹配时，如果 ~ 和 ^~ 同时匹配规则，则 ^~ 优先 ^~ 这个不会匹配请求url中后面的路径, 如上面的 /test/hello 没有匹配上 ^~ 不支持正则，和=相比，范围更广， hellowo 是可以被^~匹配，但是 = 不会匹配 ~ 路径中只要包含就可以匹配，如上面的 /test/hellowo 返回了602 测试case2: 1234567location ~ /hello &#123; return 602;&#125;location ~ /helloworld &#123; return 601;&#125; 12- 请求 localhost/world/helloworld 返回 602- 请求 localhost/helloworld 返回 602 调整一下上面的顺序之后 1234567location ~ /helloworld &#123; return 601;&#125;location ~ /hello &#123; return 602;&#125; 123- 请求 localhost/helloworld 返回601- 请求 localhost/world/helloworld 返回601- 请求 localhost/helloWorld 返回602 所以同时正则匹配时 放在前面的优先匹配 注意如果不区分大小写时，使用~* 尽量将精确匹配的放在前面 测试case3: 1234567location ^~ /hello/ &#123; return 601;&#125;location /hello/world &#123; return 602;&#125; 这种场景中，存在一个没有符号的路由规则，那么实际的测试是怎样呢？ 1234- http://localhost/hello/wor 返回601- http://localhost/hello/world 返回602- http://localhost/hello/world23 返回602- http://localhost/hello/world/123 返回602 从上面case可以看出 没有符号时，全匹配是优先于^~的 b. PartTwo: [uri]这里主要填的就是需要匹配的path路径，根据前面的符号，这里可以填写精确的path路径，也可以填正则表达式，下面则主要针对正则进行说明 123456789101112. ： 匹配除换行符以外的任意字符? ： 重复0次或1次+ ： 重复1次或更多次* ： 重复0次或更多次\\d ：匹配数字^ ： 匹配字符串的开始$ ： 匹配字符串的介绍&#123;n&#125; ： 重复n次&#123;n,&#125; ： 重复n次或更多次[c] ： 匹配单个字符c[a-z] ： 匹配a-z小写字母的任意一个小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 c. PartThree: {}匹配完毕之后内部定义一些列的处理动作，这个涉及到的点比较多，这里不详细展开，后面有空单独捞出 II. 路由转发 请求path匹配只是第一步，匹配完了之后，如何将请求转发给其他的web服务呢？ 0. 反向代理通常可见的一种使用姿势就是使用nginx，代理请求，转发到内部的tomact服务上 主要是通过 proxy_pass 这个来实现 123location ^~ /webs &#123; proxy_pass http://127.0.0.1:8080/webs;&#125; 将所有以 webs开头的请求，转发给8080端口的tomcat服务上 上面是直接写死转发到一个ip上，如果是多个机器提供服务呢？可以这么玩 12345678910## 下面放在http的括号内，作为第一层upstream test.online &#123; server 120.11.11.11:8080 weight=1; server 120.11.11.12:8080 weight=1;&#125;location ^~ /webs &#123; proxy_pass http://test.online; proxy_redirect default;&#125; 1. Rewrite命令rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。 rewrite只能放在server{},location{},if{}中， 并且只能对域名后边的除去传递的参数外的字符串起作用, 如 http://zbang.online/a/we/index.php?id=1&amp;u=str 只对/a/we/index.php重写。 语法rewrite regex replacement [flag]; 一个case，通过rewrite实现对url的重写，将下面的 12345678location ^~ /hexo &#123; root &apos;/Users/yihui/GitHub/&apos;;&#125;location ~ /hello &#123; rewrite ^(/hello).*$ /hexo/public/index.html last; return 603;&#125; 将hello开头的，全部转发到/hexo/public/index.html III. 小结1. demo将所有以blog开头的请求，全部转发到某个地方 123location ^~ /blog &#123; root &apos;/var/www/html/blog&apos;;&#125; 2. 路径匹配规则 = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 匹配顺序如下： =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 3. 路由转发 通过 proxy_pass 可以实现反向代理 通过 rewrite 可以实现路由转发 IV. 参考 location匹配顺序 nginx 常见正则匹配符号表示 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如有问题，请不吝指正，感激 扫描关注，不定时分享各种java学习笔记","categories":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"Nginx","slug":"Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/Shell/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://zbang.online/hexblog/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"https://zbang.online/hexblog/tags/配置/"}],"keywords":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"Nginx","slug":"Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/Shell/Nginx/"}]},{"title":"Centos 安装gitbook","slug":"Centos-安装gitbook","date":"2017-12-25T03:26:00.000Z","updated":"2017-12-29T04:16:00.000Z","comments":true,"path":"2017/12/25/Centos-安装gitbook/","link":"","permalink":"https://zbang.online/hexblog/2017/12/25/Centos-安装gitbook/","excerpt":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务","text":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务 1. nodejs安装1sudo yum install nodejs 2. gitbook安装12npm install gitbook -gnpm install gitbook-cli -g 上面执行完毕，可能出现一个问题 1npm: symbol SSL_set_cert_cb, version libssl.so.10 not defined in file libssl 解决方法 1yum update openssl 3. calibre安装直接到官网上下载 ； ·https://calibre-ebook.com/download· 1sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.py | sudo python -c &quot;import sys; main=lambda:sys.stderr.write(&apos;Download failed\\n&apos;); exec(sys.stdin.read()); main()&quot; 4. 测试1gitbook build . 执行完毕之后，会出现一个 _book 目录， 里面就是生成的静态网页，直接加上去即可 5. 输出pdf如果报错 1ImportError: libGL.so.1: cannot open shared object file: No such file or directory 则安装 1yum install mesa-libGL.x86_64 如果报错 1ImportError: libXrender.so.1: cannot open shared object file: No such file or directory 1yum install libXrender.so.1 -y 参考文档 基于centos6构建私有gitbook平台","categories":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"环境搭建","slug":"Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/Shell/环境搭建/"}],"tags":[{"name":"Gitbook","slug":"Gitbook","permalink":"https://zbang.online/hexblog/tags/Gitbook/"},{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"}],"keywords":[{"name":"Shell","slug":"Shell","permalink":"https://zbang.online/hexblog/categories/Shell/"},{"name":"环境搭建","slug":"Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/Shell/环境搭建/"}]},{"title":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","slug":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","date":"2017-12-17T11:53:51.000Z","updated":"2018-02-08T04:06:14.096Z","comments":true,"path":"2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","link":"","permalink":"https://zbang.online/hexblog/2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","excerpt":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来","text":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来 1. 内容说明看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下 介绍下两种拷贝方式的区别 深拷贝的辅助工具类 如何自定义实现对象拷贝 II. 深拷贝和浅拷贝0. 定义说明深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 看到上面两个简单的说明，那么问题来了 浅拷贝中，是所有的内容公用呢？还是某些内容公用？ 从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？ 1. 浅拷贝一般来说，浅拷贝方式需要实现Cloneable接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Datapublic class ShallowClone implements Cloneable &#123; private String name; private int age; private List&lt;String&gt; books; public ShallowClone clone() &#123; ShallowClone clone = null; try &#123; clone = (ShallowClone) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125; public static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(28); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.clone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(20); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); &#125;&#125; 输出结果: 12345falsesource: ShallowClone(name=newName, age=20, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript])source: ShallowClone(name=newName, age=20, books=[hello])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript]) 结果分析： 拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址 基本元素类型，两者是隔离的（虽然上面只给出了int，String） 基本元素类型包括: int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String 非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份 其实，浅拷贝有个非常简单的理解方式： 浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 = 进行赋值 这个怎么理解呢？ 上面的流程拆解就是： 1234- Object clone = new Object();- clone.a = source.a- clone.b = source.b- ... 那么=赋值有什么特点呢？ 基本数据类型是值赋值；非基本的就是引用赋值 2. 深拷贝深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已 那么上面的实例改成深拷贝应该是怎样的呢？ 可以加上这么一个方法 1234567891011121314151617181920212223242526272829303132333435363738public ShallowClone deepClone() &#123; ShallowClone clone = new ShallowClone(); clone.name = this.name; clone.age = this.age; if (this.books != null) &#123; clone.books = new ArrayList&lt;&gt;(this.books); &#125; return clone;&#125;// 简单改一下测试casepublic static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(new Integer(1280)); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.deepClone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(2000); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString());&#125; 输出结果为： 12345falsesource: ShallowClone(name=newName, age=2000, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++])source: ShallowClone(name=newName, age=2000, books=[hello])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++]) 结果分析： 深拷贝独立的对象 拷贝后对象的内容，与原对象的内容完全没关系，都是独立的 简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值 3. 应用场景区分深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了 那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？ 假设又这么一个通知对象长下面这样 12345private String notifyUser;// xxxprivate List&lt;String&gt; notifyRules; 我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样 在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了 III. 对象拷贝工具上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？ 对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝 Apache的两个版本：（反射机制） 1234org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)org.apache.commons.beanutils.BeanUtils#cloneBean Spring版本：（反射机制） 1org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties) cglib版本：（使用动态代理，效率高） 1net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter) 从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路 1. 借助反射实现对象拷贝通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值 上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125;&#125;private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; return null;&#125; 上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值 123Field field = obj.getClass().getDeclaredField(name);field.setAccessible(true);return field.get(obj); 如果找不到，则找getXXX, isXXX来获取 2. 代理的方式实现对象拷贝Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显 代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A 那么这种技术是如何使用在对象拷贝的呢？ 我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy 在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上 说明 从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了 IV. 小结1. 深拷贝和浅拷贝深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 完全独立 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性 需要实现Cloneable接口 2. 对象拷贝的两种方法通过反射方式实现对象拷贝 主要原理就是通过反射获取所有的属性，然后反射更改属性的内容 通过代理实现对象拷贝 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"clone","slug":"clone","permalink":"https://zbang.online/hexblog/tags/clone/"},{"name":"beancopy","slug":"beancopy","permalink":"https://zbang.online/hexblog/tags/beancopy/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://zbang.online/hexblog/categories/Java/JDK/"}]},{"title":"4. SPI框架实现之旅四：使用测试","slug":"SPI框架实现之旅四：使用测试","date":"2017-05-30T12:50:37.000Z","updated":"2018-02-13T03:21:17.019Z","comments":true,"path":"2017/05/30/SPI框架实现之旅四：使用测试/","link":"","permalink":"https://zbang.online/hexblog/2017/05/30/SPI框架实现之旅四：使用测试/","excerpt":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等","text":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等 1. 简单的静态使用定义一个SPI接口 IPrint, 两个实现 FilePrint, ConsolePrint 123456789101112131415161718@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125; 添加配置文件 com.hust.hui.quicksilver.spi.test.print.IPrint, 内容如下 com.hust.hui.quicksilver.spi.test.print.ConsolePrint com.hust.hui.quicksilver.spi.test.print.FilePrint 测试代码如下 1234567891011121314151617181920212223242526272829@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;); print.print(&quot;console----&gt;&quot;); print = spiLoader.getService(&quot;FilePrint&quot;); print.print(&quot;file----&gt;&quot;); try &#123; print = spiLoader.getService(&quot;undefine&quot;); print.print(&quot;undefine----&quot;); Assert.assertTrue(false); &#125; catch (Exception e) &#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125; try &#123; print = spiLoader.getService(123); print.print(&quot;type error----&quot;); Assert.assertTrue(false); &#125; catch (Exception e)&#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125;&#125; 输出如下 1234console print: console----&gt;file print: file----&gt;type error--&gt;com.hust.hui.quicksilver.spi.exception.NoSpiMatchException: no spiImpl match the name you choose! your choose is: undefinetype error--&gt;java.lang.IllegalArgumentException: conf spiInterfaceType should be sub class of [class java.lang.String] but yours:class java.lang.Integer 演示如下 2. 动态适配与静态的使用有点区别，主要的区别点在于接口的定义（需要注意第一个参数是作为选择器选择SPI实现的参数），同样是上面这个spi接口 123456789101112131415161718192021222324252627282930313233@Spipublic interface IPrint &#123; void print(String str); void adaptivePrint(String conf, String str);&#125; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"file adaptivePrint: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"console adaptivePrint: \" + str); &#125;&#125; 主要是新增了一个接口 adaptivePrint, 其他的没有啥区别，测试代码如下 12345678@Testpublic void testAdaptivePrint() throws SpiProxyCompileException &#123; IPrint print = SpiLoader.load(IPrint.class).getAdaptive(); print.adaptivePrint(\"FilePrint\", \"[file print]\"); print.adaptivePrint(\"ConsolePrint\", \"[console print]\");&#125; 输出结果 1234567891011121314151617181920212223242526file adaptivePrint: [file print]console adaptivePrint: [console print]``` 演示图 ![http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif](http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif)## 3. 自定义选择器&gt; 上面两个很简单的演示了下使用方式，最基本的方法， 没有加上 @SpiConf 注解， 没有显示指定选择器类型，下面则演示下，如何自定义选择器**SPI接口**有一个欢迎方法，我们需求根据用户的来源显示不同的欢迎至此， 下面定义了一个 `UserSelector`选择器，这个就是我们自定义的选择器```java@Spipublic interface IUser &#123; @SpiAdaptive(selector = UserSelector.class) void welcome(UserDO userDO);&#125; spi实现类 123456789101112131415public class QQUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"qq 欢迎你! \" + userDO); &#125;&#125;public class WeixinUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"weixin 欢迎你! \" + userDO); &#125;&#125; META-INF/services/ 目录下的配置如下 com.hust.hui.quicksilver.spi.def.spi.IUser com.hust.hui.quicksilver.spi.def.spi.QQUser com.hust.hui.quicksilver.spi.def.spi.WeixinUser 选择器实现如下 12345678910111213141516171819public class UserSelector implements ISelector&lt;UserDO&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, UserDO conf) throws NoSpiMatchException &#123; if (conf == null || conf.getMarket() == null) &#123; throw new IllegalArgumentException(\"userDo or userDO#market should not be null!\"); &#125; String name = conf.getMarket().getName(); if (map.containsKey(name)) &#123; return map.get(name).getSpiImpl(); &#125; throw new NoSpiMatchException(\"no spiImp matched marked: \" + conf.getMarket()); &#125;&#125; 从上面的选择器逻辑可以看出，我们是根据 UserDO的market参数来进行选择的， UserDO的定义如下 12345678910111213141516171819202122232425262728@Getter@Setter@ToStringpublic class UserDO &#123; private String uname; private String avatar; private MarketEnum market;&#125;public enum MarketEnum &#123; WEIXIN(\"WeixinUser\"), QQ(\"QQUser\"); private String name; MarketEnum(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 测试代码如下 123456789101112131415161718192021@Testpublic void testUserSPI() throws SpiProxyCompileException &#123; SpiLoader&lt;IUser&gt; loader = SpiLoader.load(IUser.class); IUser user = loader.getAdaptive(); UserDO weixinUser = new UserDO(); weixinUser.setAvatar(\"weixin.avatar.jpg\"); weixinUser.setUname(\"微信用户\"); weixinUser.setMarket(MarketEnum.WEIXIN); user.welcome(weixinUser); UserDO qqUser = new UserDO(); qqUser.setAvatar(\"qq.avatar.jpg\"); qqUser.setUname(\"qq用户\"); qqUser.setMarket(MarketEnum.QQ); user.welcome(qqUser); System.out.println(\"-----over------\");&#125; 输出结果: weixin 欢迎你! UserDO(uname=微信用户, avatar=weixin.avatar.jpg, market=WEIXIN) qq 欢迎你! UserDO(uname=qq用户, avatar=qq.avatar.jpg, market=QQ) 演示如下: 3. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}]},{"title":"3. SPI框架实现之旅三：实现说明","slug":"SPI框架实现之旅三：实现说明","date":"2017-05-29T02:50:37.000Z","updated":"2018-02-13T03:21:17.019Z","comments":true,"path":"2017/05/29/SPI框架实现之旅三：实现说明/","link":"","permalink":"https://zbang.online/hexblog/2017/05/29/SPI框架实现之旅三：实现说明/","excerpt":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下：","text":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下： SpiLoader 全解析 spiImpl选择的核心类，包括初始化选择器，初始化spiImpl实现列表，解析spiImpl的选择条件，返回具体的实现类等 1. 获取spiLoader对象 SpiLoader 是一个泛型对象，每个SPI接口，对应一个SpiLoader&lt;T&gt; 对象，我们提供了一个静态方法来获取这个对象 实现优先从缓存中获取， 如果缓存没有，则新建一个；缓存中有， 则直接返回 123456789101112131415161718192021222324252627282930/*** spiLoader缓存, 其中key为 spi接口, value为对应的Loader对象*/private static final ConcurrentMap&lt;Class&lt;?&gt;, SpiLoader&lt;?&gt;&gt; loaderCache = new ConcurrentHashMap&lt;&gt;();@SuppressWarnings(\"unchecked\")public static &lt;T&gt; SpiLoader&lt;T&gt; load(Class&lt;T&gt; type) &#123; if (null == type) &#123; throw new IllegalArgumentException(\"common cannot be null...\"); &#125; if (!type.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must be interface!\"); &#125; if (!withSpiAnnotation(type)) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must have the annotation of @Spi\"); &#125; SpiLoader&lt;T&gt; spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); if (spiLoader == null) &#123; loaderCache.putIfAbsent(type, new SpiLoader&lt;&gt;(type)); spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); &#125; return spiLoader;&#125; 说明 上面有几个校验，前一篇已经说明，不再赘述 上面新建对象，不是线程安全的 2. 新建 SpiLoader对象 创建对象，主要会初始化选择器 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private SpiLoader(Class&lt;T&gt; type) &#123; // 初始化默认的选择器, 为保留项目, 必然会提供的服务 selectorInstanceCacheMap.putIfAbsent(DefaultSelector.class, DEFAULT_SELECTOR); this.spiInterfaceType = type; initSelector();&#125;private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 持有一个选择器缓存列表，selectorInstanceCacheMap 保证每种类型的选择器，在这个SpiLoader中，只会有一个实例存在 不做成全局唯一的原因是尽量隔离, 比如 ParamsSelector 内部缓存了spi实现的列表，如果全局公用的话，就会混掉，导致这个列表中就出现非这个spi接口的实现类 类选择器 + 方法选择器 currentSelector ： 类选择器, 解析 @Spi 注解获取，适用于静态选择 + 动态选择两种使用方式 currentMethodSelector : 方法选择器，解析 @SpiAdaptive 注解获取， 仅适用于动态选择SPI实现的方式 优先级： 方法上定义的选择器 由于 类上定义的选择器； 方法上未定义时，默认使用类定义的选择器 3. 静态使用 静态使用方式，表示根据传入的条件，选择一个满足条件的实现返回 实现1234567891011121314151617181920212223242526272829303132333435/*** 根据传入条件, 选择具体的spi实现类* &lt;p/&gt;* 这里要求conf的类型和选择器的参数类型匹配, 否则会尝试使用默认的选择器补救, 若补救失败, 则抛异常** @param conf* @return* @throws NoSpiMatchException* @throws IllegalArgumentException*/@SuppressWarnings(\"unchecked\")public T getService(Object conf) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; if (!currentSelector.getConditionType().isAssignableFrom(conf.getClass())) &#123; /** * 参数类型不匹配时, 判断是否可以根据默认的选择器来获取 */ if (conf instanceof String) &#123; return (T) DEFAULT_SELECTOR.getSelector().selector(spiImplClassCacheMap, conf); &#125; /** * 参数类型完全不匹配, 则抛参数异常 */ throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; return (T) currentSelector.getSelector().selector(spiImplClassCacheMap, conf);&#125; 说明 spiImplClassCacheMap spi实现的缓存映射表，优先判断缓存映射表是否存在，不存在时需要初始化；存在时，则进入校验逻辑 校验 校验传入的参数，是否匹配当前的选择器参数类型，为了保证选择器可以正常运行 当不匹配时，会有一个兼容逻辑，判断传参类型是否为String， 是则采用默认的选择器，根据name来选择spi实现 （这种实现可能造成选择的实现不是预期的） 静态使用方式，使用类定义选择器 : currentSelector 静态使用的方式，目标就是事前就确认使用这个实现了，不会出现变动了； 相当于一次确认，所有的调用都是确认的 静态使用，方法注解的选择器无效。这个我们从逆向的思路进行解释 IPrint 是一个Spi接口， 有两个实现 FilePrint, ConsolePrint 假设 `currentSelector=DefaultSelector`， 方法 methodA 上定义的是 ParamsSelector 时 静态使用方式，获取一个spi实现，希望在所有的spi接口使用处，都输出到文件，用户根据 `FilePrint` 选择 FilePrint 这个类来执行具体的输出逻辑， 如果在调用 methodA 方法执行时， 假设根据 ParamsSelector 判断， ConsolePrint 才满足这儿条件，这是相当于在具体实现时，换成了另一个 ConsolePrint, 这下子就与我们的初衷背离了（如果目标是想实现这个场景，显然动态适配的方式才是正确的使用姿势） loadService 的逻辑后面详细说明 4. 动态使用 动态使用区别于静态的直接确定实现类， 通过getService 获取的并不是某个特定对的实现类，而是一个动态生成的代理，每次具体执行之前，会去判断一下，应该选择哪一个实现来执行 设计的出发点可以考虑下，我们的目标是在执行方法之前，需要判断一下哪个实现类满足要求，选择这个实现类来执行这个方法，那么我们可以怎么去做？ 考虑到切面的方式，如果有一种手段，在方法执行之前，织入一段业务逻辑，就可以达到上面的目的 最开始虽然是怎么想的，但是有点尴尬的是，不知道怎么去实现；因此换了一个思路，我自己新生成一个接口的实现类，在这个实现类里面做选择逻辑，然后把这个实现类对象返回 实现如下和静态实现的逻辑差不多，一般流程如下: 判断spi实现类的映射关系表是否初始化，若没有则初始化 获取选择器 优先从方法选择器中查找， 若存在，则直接选中； 不存在，则使用类选择器 校验：判断传入条件参数类型是否满足选择器的参数类型匹配（将方法的第一个参数，作为选择器的选择条件） 返回实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@SuppressWarnings(\"unchecked\")public T getService(Object conf, String methodName) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; // 首先获取对应的selector SelectorWrapper selector = currentMethodSelector.get(methodName); if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector); &#125; if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; selector = DEFAULT_SELECTOR; &#125; if (spiImplMethodCacheMap.size() == 0) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; try &#123; // 采用默认的选择器,根据指定name 进行查询时, 需要兼容一下, 因为method对应的缓存key为 SpiImpName_methodName if (DEFAULT_SELECTOR.equals(selector)) &#123; if (spiImplMethodCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; if (spiImplClassCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf + \"_\" + methodName); &#125; else &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; &#125; catch (Exception e) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125;&#125; 说明 这个方法通常是由框架生成的代理实现类来调用（后面会说明动态生成代理类的逻辑） 区别与静态使用方式， 优先根据方法名，查找对应的选择器；当未定义时，使用类选择器 默认选择器，根据name来查询实现时，传入的参数特殊处理下，主要是因为 spiImplMethodCacheMap 中key的生成，有一个小转换 若实现类上没有 @SpiConf注解，或者 @SpiConf的注解没有定义 name 属性，则类的唯一标识name为：简单类名； 否则为指定的name属性 若方法上显示使用 @SpiConf 指定了name属性，则key的生成规则为： 方法注解上指定的name； 如果没有 @SpiConf注解，或其中没有指定name属性，则key生成规则: 类name属性 + 下划线 + 方法名 这一点单独看可能不太好理解，因此可以和下面的spi实现类映射关系的初始化结合起来 动态生成代理类的逻辑，放在最后进行说明 5. spi实现类映射关系表初始化 为了避免每次选择具体的实现类时，都去加载一遍，耗时耗力好性能，因此加一个缓存是很有必要的，这里主要说下这个实现逻辑，以及为啥这么干 缓存结构使用了两个Map： 一个是类级别的映射关系 spiImplClassCacheMap 静态使用时，只会用搞这个 动态适配时，当下面的映射关系中无法获取满足条件的实现时，会再次从这里进行判断 key： @SpiConf 注解中定义的name； 或者spi实现类的简单类名 一个是方法的映射关系 spiImplMethodCacheMap 动态适配时， 选择器优先从这里进行判断 key: @SpiConf 注解中定义的name； 或者是 实现类的 name + “_” + 方法名 12345678910/*** name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplClassCacheMap;/*** 自适应时, 根据方法选择实现; name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplMethodCacheMap; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101private void loadSpiService() &#123; List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;(); List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceMethodList = new ArrayList&lt;&gt;(); ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType); SpiConf spiConf; String implName; int implOrder; for (T t : serviceLoader) &#123; spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); String methodImplName; int methodImplOrder; Map&lt;String, String&gt; methodParams; for (Method method : methods) &#123; spiConf = method.getAnnotation(SpiConf.class); if (spiConf == null) &#123; continue; &#125; // 方法上有自定义注解, 且定义的name与类实现名不同, 则直接采用 // 否则采用 ServiceName_MethodName 方式定义 if (StringUtils.isBlank(spiConf.name()) || implName.equals(spiConf.name())) &#123; methodImplName = implName + \"_\" + method.getName(); &#125; else &#123; methodImplName = spiConf.name(); &#125; // 优先级, 以最小的为准 （即一个类上的优先级很低, 也可以定义优先级高的方法） // 方法注解未定义顺序时, 继承类上的顺序 methodImplOrder = Math.min(implOrder, spiConf.order() &lt; 0 ? implOrder : spiConf.order()); // 自适应方法的参数限制, 要求继承类上的参数 methodParams = parseParms(spiConf.params()); if (map.size() &gt; 0) &#123; // 方法的参数限定会继承类上的参数限定 if (methodParams.size() == 0) &#123; methodParams = map; &#125; else &#123; methodParams.putAll(map); &#125; &#125; spiServiceMethodList.add(new SpiImplWrapper&lt;&gt;(t, methodImplOrder, methodImplName, methodParams)); &#125; &#125; if (spiServiceList.size() == 0) &#123; throw new IllegalStateException(\"no spiImpl implements spi: \" + spiInterfaceType); &#125; this.spiImplClassCacheMap = initSpiImplMap(spiServiceList); this.spiImplMethodCacheMap = initSpiImplMap(spiServiceMethodList);&#125;private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; initSpiImplMap(List&lt;SpiImplWrapper&lt;T&gt;&gt; list) &#123; // 映射为map, 限定不能重名 Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; tempMap = new ConcurrentHashMap&lt;&gt;(); for (SpiImplWrapper&lt;T&gt; wrapper : list) &#123; if (tempMap.containsKey(wrapper.getName())) &#123; throw new IllegalArgumentException(\"duplicate spiImpl name \" + wrapper.getName()); &#125; tempMap.put(wrapper.getName(), wrapper); &#125; return tempMap;&#125; 上面的逻辑可以分为两块，一块是上半边的初始化，获取spiImplClassCacheMap;下一块则是扫描实现类的所有方法，将方法上标有@SpiConf注解的捞出来，用于初始化 spiImplMethodCacheMap 说明 缓存结构中value为 SpiImplWrapper 缓存value并不是简单的实现类，封装类的定义如下，将条件和排序也同时封装进去了 1234567891011121314151617181920private T spiImpl;private int order;/*** spiImpl 的标识name, 要求唯一* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.DefaultSelector 选择具体的SpiImpl 时使用&#125;*/private String name;/*** 参数校验规则* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.ParamsSelector&#125; 选择具体的SpiImpl 时使用* 要求每个实现类都有注解 &#123;@link SpiConf&#125;*/private Map&lt;String, String&gt; paramCondition; name 的定义，类与方法两个纬度的缓存中，定义规则不同，具体可以看《缓存结构》这里的说明 采用 ParamsSelector 时， 要求 @SpiConf 注解必须存在 注意扫描所有方法对应的注解, spi实现类，如果存在继承则会出现问题 // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); 动态代码生成 上面在谈论动态使用的时候，采用的方案是，生成一个代理类，实现spi接口， 在具体的实现逻辑中，使用选择器来获取满足条件的实现类，然后执行相应的方法 1. 代理类格式采用倒推方式，先给出一个实际的代理类如下，具体的实现中其实只有两行代码 获取具体的实现类 （调用上面的 SpiLoader.getService(conf, methodName） 执行实现类的接口 123456789101112131415161718192021222324package com.hust.hui.quicksilver.spi.test.print;import com.hust.hui.quicksilver.spi.SpiLoader;public class IPrint$Proxy implements com.hust.hui.quicksilver.spi.test.print.IPrint &#123; public void print(java.lang.String arg0) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"print\"); spiImpl.print(arg0); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125; public void adaptivePrint(java.lang.String arg0, java.lang.String arg1) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"adaptivePrint\"); spiImpl.adaptivePrint(arg0, arg1); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125;&#125; 上面给出了一个代理类的演示，那么剩下两个问题，一个是如何生成代理类； 一个是如何运行代理类（上面是java代码，我们知道运行得是字节码才行） 代理类生成对着上面的实现，反推代码生成，其实比较简单了，无非就是生成一大串的String罢了，这里真没什么特殊的，贴下实现，逻辑省略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 构建SPI接口的实现代理类, 在执行动态适配的方法时, 调用SpiLoader的 spiImpl选择器, 选择具体的实现类执行 * * @return */public static String buildTempImpl(Class type) &#123; StringBuilder codeBuilder = new StringBuilder(); codeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\"); codeBuilder.append(\"\\nimport \").append(SpiLoader.class.getName()).append(\";\"); codeBuilder.append(\"\\npublic class \").append(type.getSimpleName()).append(\"$Proxy implements \").append(type.getCanonicalName()).append(\" &#123;\\n\"); Method[] methods = type.getMethods(); for (Method method : methods) &#123; Class&lt;?&gt; returnType = method.getReturnType(); //函数返回值 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();//函数参数列表 Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();//函数异常列表 // build method code StringBuilder code = new StringBuilder(512); if (parameterTypes.length &lt; 0) &#123; //检查该函数参数列表中，第一个参数作为选择器参数 code.append(\"throw new IllegalArgumentException(\\\"there should be one argument for selector to choose spiImpl\\\")\"); &#125; else &#123; // 没有 SpiAdaptive注解的, 采用默认的注解方式 code.append(\"try&#123;\\n\"); code.append(type.getName()).append(\" spiImpl=\") .append(\"SpiLoader.load(\") .append(type.getName()).append(\".class\") .append(\").getService(arg0,\\\"\") .append(method.getName()) .append(\"\\\");\"); if (!\"void\".equals(returnType.getName())) &#123; code.append(\"return \"); &#125; code.append(\"spiImpl.\").append(method.getName()).append(\"(arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; code.append(\",\").append(\"arg\").append(i); &#125; code.append(\");\"); code.append(\"\\n&#125; catch(com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e)&#123;\\nthrow new java.lang.RuntimeException(e);\\n&#125;\"); &#125; // build method signature codeBuilder.append(\"\\npublic \").append(returnType.getName()).append(\" \").append(method.getName()) .append(\"(\").append(parameterTypes[0].getName()).append(\" arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; codeBuilder.append(\", \").append(parameterTypes[i].getName()).append(\" arg\").append(i); &#125; codeBuilder.append(\") \"); if (exceptionTypes.length &gt; 0) &#123; codeBuilder.append(\"throw \").append(exceptionTypes[0].getName()); for (int i = 1; i &lt; exceptionTypes.length; i++) &#123; codeBuilder.append(\", \").append(exceptionTypes[i].getName()); &#125; &#125; codeBuilder.append(\"&#123;\\n\"); codeBuilder.append(code.toString()).append(\"\\n&#125;\"); &#125; codeBuilder.append(\"\\n&#125;\"); return codeBuilder.toString();&#125; 动态编译运行动态编译，最开始想的是利用jdk的动态编译方式，试来试去没搞成功，然后选择了一个折中的方案，把代理类看成是groovy代码，利用 GroovyEngine 来实现动态运行, 这一块的逻辑也超级简单，下面的短短几行代码即可； 后面有空单独研究下java的动态编译 12345678910111213141516@SuppressWarnings(\"unchecked\")public static &lt;T&gt; T compile(String code, Class&lt;T&gt; interfaceType, ClassLoader classLoader) throws SpiProxyCompileException &#123; GroovyClassLoader loader = new GroovyClassLoader(classLoader); Class clz = loader.parseClass(code); if (!interfaceType.isAssignableFrom(clz)) &#123; throw new IllegalStateException(\"illegal proxy type!\"); &#125; try &#123; return (T) clz.newInstance(); &#125; catch (Exception e) &#123; throw new SpiProxyCompileException(\"init spiProxy error! msg: \" + e.getMessage()); &#125;&#125; 小结至此，核心的东西基本上都过了一遍，主要的设计思路，实现逻辑，执行流程都说完了 博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}]},{"title":"2. SPI框架实现之旅二：整体设计","slug":"SPI框架实现之旅二：整体设计","date":"2017-05-28T02:50:37.000Z","updated":"2018-02-13T03:21:17.019Z","comments":true,"path":"2017/05/28/SPI框架实现之旅二：整体设计/","link":"","permalink":"https://zbang.online/hexblog/2017/05/28/SPI框架实现之旅二：整体设计/","excerpt":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式","text":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式 设计思路下图围绕 SpiLoader 为中心，描述了三个主要的流程： load所有的spi实现 初始化选择器 selector 获取spi实现类 （or一个实现类代理） 基础类说明 主要介绍一下框架中涉及到的接口和注解，并指出需要注意的点 1. Selector 选择器 为了最大程度的支持业务方对spi实现类的选择，我们定义了一个选择器的概念，用于获取spi实现类 接口定义如下:123public interface ISelector&lt;T&gt; &#123; &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, T conf) throws NoSpiMatchException;&#125; 结合上面的接口定义，我们可以考虑下，选择器应该如何工作？ 根据传入的条件，从所有的实现类中，找到一个最匹配的实现类返回 如果查不到，则抛一个异常NoSpiMatchException出去 所以传入的参数会是两个， 一个是所有的实现类列表map（至于上面为什么用map，后续分析），一个是用于判断的输入条件conf 框架中会提供两种基本的选择器实现， DefaultSelector ， 对每个实现类赋予唯一的name，默认选择器则表示根据name来查找实现类 ParamsSelector， 在实现类上加上 @SpiConf 注解，定义其中的 params，当传入的参数(conf)， 能完全匹配定义的params，表示这个实现类就是你所需要的 自定义实现自定义实现比较简单，实现上面的接口即可 2. Spi 注解 要求所有的spi接口，都必须有这个注解； 定义如下主要是有一个参数，用于指定是选择器类型，定义spi接口的默认选择器， 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Spi &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明在上一篇《SPI框架实现之旅一》中，使用jdk的spi方式中，并没有使用注解依然可以正常工作，我们这里定义这个注解且要求必需有，出于下面几个考虑 醒目，告诉开发者，这个接口是声明的spi接口， 使用的时候注意下 加入选择器参数，方便用户扩展自己的选择方式 3. SpiAdaptive 注解 对需要自适应的场景，为了满足一个spi接口，应用多重不同的选择器场景，可以加上这个注解；如果不加这个注解，则表示采用默认的选择器来自适应 接口说明1234567891011/** * SPI 自适应注解, 表示该方法会用到spi实现 * &lt;p/&gt; * Created by yihui on 2017/5/24. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface SpiAdaptive &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明这个注解内容和 @Spi 基本上一模一样，唯一的区别是一个放在类上，一个放在方法上，那么为什么这么考虑？ @Spi 注解放在类上，更多的表名这个接口是我们定义的一个SPI接口，但是使用方式可以有两种（静态 + 动态确认） @SpiAdaptive 只能在自适应的场景下使用，用于额外指定spi接口中某个方法的选择器 （如果一个spi接口全部只需要一个选择器即可，那么可以不使用这个注解） 如下面的这个例子，print方法和 echo方法其实是等价的，都是采用 DefaultSelector 来确认具体的实现类；而 write 和 pp 方法则是采用 ParamsSelector 选择器; 1234567891011121314151617181920/** * Created by yihui on 2017/5/25. */@Spipublic interface ICode &#123; void print(String name, String contet); @SpiAdaptive void echo(String name, String content); @SpiAdaptive(selector = ParamsSelector.class) void write(Context context, String content); @SpiAdaptive(selector = ParamsSelector.class) void pp(Context context, String content);&#125; 4. SpiConf 注解 这个主键主要是用在实现类上（或实现类的方法上），里面存储一些选择条件，通常是和Selector搭配使用 定义如下定义了三个字段: name 唯一标识，用于 DefaultSelector； params 参数条件， 用于 ParamsSelector； order : 优先级， 主要是为了解决多个实现类都满足选择条件时， 应该选择哪一个 （谈到这里就有个想法， 通过一个参数，来选择是否让满足条件的全部返回） 123456789101112131415161718192021222324252627282930@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface SpiConf &#123; /** * 唯一标识 * * @return */ String name() default \"\"; /** * 参数过滤, 单独一个元素,表示参数必须包含; 用英文分号,左边为参数名,右边为参数值,表示参数的值必须是右边的 * &lt;p/&gt; * 形如 &#123;\"a\", \"a:12\", \"b:TAG\"&#125; * * @return */ String[] params() default &#123;&#125;; /** * 排序, 越小优先级越高 * * @return */ int order() default -1;&#125; 说明SpiConf 注解可以修饰类，也可以修饰方法，因此当一个实现类中，类和方法都有这个注解时， 怎么处理 ？ 以下面的这个测试类进行说明 1234567891011121314151617181920212223242526272829303132333435/** * Created by yihui on 2017/5/25. */@SpiConf(params = \"code\", order = 1)public class ConsoleCode implements ICode &#123; @Override public void print(String name, String contet) &#123; System.out.println(\"console print:---&gt;\" + contet); &#125; /** * 显示指定了name, 因此可以直接通过 consoleEcho 来确定调用本实现方法 * @param name * @param content */ @Override @SpiConf(name = \"consoleEcho\") public void echo(String name, String content) &#123; System.out.println(\"console echo:----&gt;\" + content); &#125; /** * 实际的优先级取 方法 和类上的最高优先级, 实际为1； * `ParamsSelector`选择器时， 执行该方法的条件等同于 `&#123;\"code\", \"type:console\"&#125;` * @param context * @param content */ @Override @SpiConf(params = &#123;\"type:console\"&#125;, order = 3) public void write(Context context, String content) &#123; System.out.println(\"console write:----&gt;\" + content); &#125;&#125; 在设计中，遵循下面几个原则： 类上的SpiConf注解， 默认适用与类中的所有方法 方法上有SpiConf注解，采取下面的规则 方法注解声明name时，两个会同时生效，即想调用上面的echo方法， 通过传入 ConsoleCode（类注解不显示赋值时，采用类名代替） 和 consoleEcho 等价 方法注解未声明name时，只能通过类注解上定义的name（or默认的类名）来选择 order，取最高优先级，如上面的 write 方法的优先级是 1; 当未显示定义order时，以定义的为准 params: 取并集，即要求类上 + 方法上的条件都满足 SPI加载器 spi加载器的主要业务逻辑集中在 SpiLoader 类中，包含通过spi接口，获取所有的实现类； 获取spi接口对应的选择器 （包括类对应的选择器， 方法对应的选择器）； 返回Spi接口实现类（静态确认的实现类，自适应的代理类） 从上面的简述，基本上可以看出这个类划分为三个功能点， 下面将逐一说明，本篇博文主要集中在逻辑的设计层，至于优化（如懒加载，缓存优化等） 放置下一篇博文单独叙述 1. 加载spi实现类 这一块比较简单，我们直接利用了jdk的 ServiceLoader 来根据接口，获取所有的实现类；因此我们的spi实现，需要满足jdk定义的这一套规范 具体的代码业务逻辑非常简单，大致流程如下 1234567891011121314151617 if (null == spiInterfaceType) &#123; throw new IllegalArgumentException(\"common cannot be null...\");&#125;if (!spiInterfaceType.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must be interface!\");&#125;if (!withSpiAnnotation(spiInterfaceType)) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must have the annotation of @Spi\");&#125; ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType);for(T spiImpl: serviceLoader) &#123; // xxx&#125; 注意 因为使用了jdk的标准，因此每定义一个spi接口，必须在 META_INF.services 下新建一个文件， 文件名为包含包路径的spi接口名， 内部为包含包路径的实现类名 每个spi接口，要求必须有 @Spi 注解 Spi接口必须是 interface 类型， 不支持抽象类和类的方式 拓展虽然这里直接使用了spi的规范，我们其实完全可以自己定义标准的，只要能将这个接口的所有实现类找到， 怎么实现都可以由你定义 如使用spring框架后，可以考虑通过 applicationContext.getBeansOfAnnotaion(xxx ) 来获取所有的特定注解的bean，这样就可以不需要自己新建一个文件，来存储spi接口和其实现类的映射关系了 构建spi实现的关系表上面获取了spi实现类，显然我们的目标并不局限于简单的获取实现类，在获取实现类之后，还需要解析其中的 @SpiConf 注解信息，用于表示要选择这个实现，必须满足什么样的条件 SpiImplWrapper : spi实现类，以及定义的各种条件的封装类 注解的解析过程流程如下: name: 注解定义时，采用定义的值； 否则采用简单类名 （因此一个系统中不允许两个实现类同名的情况） order： 优先级， 注解定义时，采用定义的值；未定义时采用默认； params: 参数约束条件， 会取类上和方法上的并集（原则上要求类上的约束和方法上的约束不能冲突） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;();// 解析注解spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; // 没有添加注解时， 采用默认的方案 implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // ------------ // 解析参数的方法 private Map&lt;String, String&gt; parseParms(String[] params) &#123; if (params.length == 0) &#123; return Collections.emptyMap(); &#125; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(params.length); String[] strs; for (String param : params) &#123; strs = StringUtils.split(param, \":\"); if (strs.length &gt;= 2) &#123; map.put(strs[0].trim(), strs[1].trim()); &#125; else if (strs.length == 1) &#123; map.put(strs[0].trim(), null); &#125; &#125; return map; &#125; 2. 初始化选择器 我们的选择器会区分为两类，一个是类上定义的选择器， 一个是方法上定义的选择器； 在自适应的使用方式中，方法上定义的优先级 &gt; 类上定义 简单来讲，初始化选择器，就是扫一遍SPI接口中的注解，实例化选择器后，缓存住对应的结果, 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /*** 选择器, 根据条件, 选择具体的 SpiImpl;*/private SelectorWrapper currentSelector;/*** 自适应时, 方法对应的选择器*/private Map&lt;String, SelectorWrapper&gt; currentMethodSelector;/*** 每一个 SpiLoader 中, 每种类型的选择器, 只保存一个实例* 因此可以在选择器中, 如&#123;@link ParamsSelector&#125; 对spiImplMap进行处理并缓存结果*/private ConcurrentHashMap&lt;Class, SelectorWrapper&gt; selectorInstanceCacheMap = new ConcurrentHashMap&lt;&gt;(); private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 SeectorWrapper 选择器封装类 这里我们在获取选择器时，特意定义了一个封装类，其中包含具体的选择器对象，以及所匹配的参数类型，因此可以在下一步通过选择器获取实现类时，保证传入的参数类型合法 private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) 具体的实例化选择器的方法 从实现来看，优先从选择器缓存中获取选择器对象，这样的目的是保证一个spi接口，每种类型的选择器只有一个实例；因此在自定义选择器中，你完全可以做一些选择判断的缓存逻辑，如 ParamsSelector 中的spi实现类的有序缓存列表 currentSelector , currentMethodSelector, selectorInstanceCacheMap currentSelector: 对应的是类选择器，每个SPI接口必然会有一个，作为打底的选择器 currentMethodSelector: 方法选择器映射关系表，key为方法名，value为该方法对应的选择器； 所以spi接口中，不支持重载 selectorInstanceCacheMap: spi接口所有定义的选择器映射关系表，key为选择器类型，value是实例；用于保障每个spi接口中选择器只会有一个实例 3. 获取实现类 对使用者而言，最关注的就是这个接口，这里会返回我们需要的实现类（or代理）；内部的逻辑也比较清楚，首先确定选择器，然后通过选择器便利所有的实现类，把满足条件的返回即可 从上面的描述可以看到，主要分为两步 获取选择器 根据选择器，遍历所有的实现类，找出匹配的返回 获取选择器初始化选择器之后，我们会有 currentSelector , currentMethodSelector 两个缓存 静态确定spi实现时，直接用 currentSelector 即可 （spi接口中所有方法都公用类定义选择器） 动态适配时， 根据方法名在 currentMethodSelector 中获取选择器，如果没有，则表示该方法没有@SpiAdaptive注解，直接使用类的选择器 currentMethodSelector 即可 123456789101112131415// 动态适配时，获取方法对应对应的selector实现逻辑SelectorWrapper selector = currentMethodSelector.get(methodName);if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector);&#125;if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; // 参数不匹配时，且传入的参数为String类型， 则尝试使用默认选择器进行兼容（不建议在实现时，出现这种场景） selector = DEFAULT_SELECTOR;&#125; 选择实现类这个的主要逻辑就是遍历所有的实现类，判断是否满足选择器的条件，将第一个找到的返回即可，所有的业务逻辑都在 ISelector 中实现，如下面给出的默认选择器，根据name来获取实现类 1234567891011121314151617181920212223242526/** * 默认的根据name 获取具体的实现类 * &lt;p/&gt; * Created by yihui on 2017/5/24. */public class DefaultSelector implements ISelector&lt;String&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, String name) throws NoSpiMatchException &#123; if (StringUtils.isBlank(name)) &#123; throw new IllegalArgumentException(\"spiName should not be empty!\"); &#125; if (map == null || map.size() == 0) &#123; throw new IllegalArgumentException(\"no impl spi!\"); &#125; if (!map.containsKey(name)) &#123; throw new NoSpiMatchException(\"no spiImpl match the name you choose! your choose is: \" + name); &#125; return map.get(name).getSpiImpl(); &#125;&#125; 流程说明 上面主要就各个点单独的进行了说明，看起来可能比较分散，看完之后可能没有一个清晰的流程，这里就整个实现的流程顺一遍，主要从使用者的角度出发，当定义了一个SPI接口后，到获取spi实现的过程中，上面的这些步骤是怎样串在一起的 流程图先拿简单的静态获取SPI实现流程说明（动态的其实差不多，具体的差异下一篇说明），先看下这种用法的使用姿势 1234567891011121314151617181920212223242526@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125;@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(\"ConsolePrint\"); print.print(\"console----&gt;\");&#125; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class);这行代码触发的action 主要是初始化所有的选择器, 如下图 首先从缓存中查 是否已经初始化过了有则直接返回； 缓存中没有，则进入new一个新的对象出来 解析类上注解 @Spi，初始化 currentSelector 解析所有方法的注解 @SpiAdaptive ， 初始化 currentMethodSelector 塞入缓存，并返回 IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;);根据name获取实现类，具体流程如下 判断是否加载过所有实现类 spiImplClassCacheMap 没有加载，则重新加载所有的实现类 通过jdk的 ServiceLoader.load() 方法获取所有的实现类 遍历实现类，根据 @SpiConf 注解初始化参数，封装 SpiImplWrapper对象 保存封装的 SpiImplWrapper对象到缓存 执行 currentSelector.select() 方法，获取匹配的实现类 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}]},{"title":"1. SPI框架实现之旅一：背景介绍","slug":"SPI框架实现之旅一：背景介绍","date":"2017-05-26T02:46:42.000Z","updated":"2018-02-13T03:21:17.018Z","comments":true,"path":"2017/05/26/SPI框架实现之旅一：背景介绍/","link":"","permalink":"https://zbang.online/hexblog/2017/05/26/SPI框架实现之旅一：背景介绍/","excerpt":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制","text":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制 1. 背景上面摘抄了一下spi的概念，接着以个人的理解，简单的谈一下为什么会用到SPI， 什么场景下可以用到这个， 以及使用了SPI机制后有什么优越性 什么是SPI虽然最开始就引用了spi的解释，这里浅谈一下个人理解。Service Provider Interface 以接口方式提供服务， 和API不同，spi的机制是定义一套标准规范的接口，实现交给其他人来做。 所以一个接口，可以有很多的实现，你完全可以根据自己的需要去选择具体的实现方式，因为是面向接口的开发，所以你的业务代码基本上就不用修改，就可以切到另一个实现了 什么场景可以用 分别从框架层面和业务层面，给出一个我认为比较合适的场景 1. 日志输出 SLF4jSLF4j：大名鼎鼎的日志输出接口，这个jar包里面提供的都只是接口方式，具体的实现需要自己去实现，当然比较常用的 logback 就是一个具体的实现包了， 在项目中使用 slf4j 的api进行日志的输出， 通过简单的配置，引入logback， 就可以使用logback来实现具体的日志输出； 也可以换一个日志实现 commons-logging，业务上不需要任何的改动，就可以用不同的实现来输出日志 2. 业务场景假设你现在有个用户注册成功后的欢迎用户的业务，不同渠道（微信，qq，微博等）注册的，显示的欢迎不同，对此有两种不同的实现方式 如果每个不同的渠道进来的，都有一个独立的应用来响应 （因为绝大多数的业务都一样，可能就欢迎词不同，如果做到代码最大程度的复用） 只有一个应用，来处理所有的这些场景 可以怎么用 结合上面的业务场景，来描述下可以怎么用 1. 代码复用为了实现代码最大程度的复用，那么可以将不同的地方，抽象成一个SPI接口，在业务层通过接口来代替具体的实现类实现业务逻辑； 每个渠道，都有个独立的应用，那么在微信渠道，创建一个 WeixinSpiImpl来实现接口 在qq渠道，实现 QQSpiImpl；那么在具体的接口调用处，实际上就是执行的spi实现类方法 2. 业务场景的选择区分这个与上面不同，同一个服务接口，根据不同的业务场景，选择不同的实现来执行；当然你是完全可以使用 if， else来实现这种场景，唯一的问题就是扩展比较麻烦； 这种场景下，我们希望的就是这个接口，能自动的根据业务场景，来选择最合适的实现类来执行 简单来讲，就是\u0010spi接口执行之前，其实需要有一个自动选择匹配的实现类的前置过程； 通常这种业务场景下，具体的spi实现会有多个，但是需要有一个选择的策略 2. 小目标 在具体的实现之前，先定义一个小目标，我们想要实现一个什么样子的东西出来 通过上面的背景描述，我们的小目标也就很明确了，我们的实现至少需要满足两个场景 静态选择SPI实现， 即在选择完成之后，所有对这个spi接口的引用都是确定由这个实现来承包 动态选择SPI实现， 不到运行之时，你都不知道会是哪个spi实现来干这件事 3. 技术储备 java本身就提供了一套spi的支持方式: ServiceLoader，我们后续的开发，也会在这个基础之上进行 利用java的 ServiceLoader 找到服务接口的实现类，有一些约定，下面给出要求说明和一个测试case 一般实现流程 定义spi接口 ： IXxx 具体的实现类: AXxx, BXxx 在jar包的META-INF/services/目录下新建一个文件，命名为 spi接口的完整类名，内容为spi接口实现的完整类名，一个实现类占一行 测试case如下 spi接口 com.hust.hui.quicksilver.commons.spi.HelloInterface 12345678910package com.hust.hui.quicksilver.commons.spi;/** * Created by yihui on 2017/3/17. */public interface HelloInterface &#123; void sayHello();&#125; spi接口的两个实现类 com.hust.hui.quicksilver.commons.spi.impl.ImageHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class ImageHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"image hello!\"); &#125;&#125; com.hust.hui.quicksilver.commons.spi.impl.TextHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class TextHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"text hello\"); &#125;&#125; 配置文件 com.hust.hui.quicksilver.commons.spi.HelloInterface 12com.hust.hui.quicksilver.commons.spi.impl.ImageHellocom.hust.hui.quicksilver.commons.spi.impl.TextHello 测试类 1234567891011public class HelloSpiTest &#123; @Test public void testSPI() &#123; ServiceLoader&lt;HelloInterface&gt; serviceLoader = ServiceLoader.load(HelloInterface.class); for (HelloInterface hello: serviceLoader) &#123; hello.sayHello(); &#125; &#125;&#125; 输出如下: 12image hello!text hello 测试类演示如下图: 4. 设计思路画了一下结构图，方便理解, 下面的核心是 SpiLoader 类， 负责加载spi接口的所有实现类， 初始化所有定义的选择器， 返回一个spi接口的实现类初始化用户自定义的spi对象，然后用户持有此对象调用spi接口中提供的方法即可 5. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"}],"keywords":[{"name":"Quick系列项目","slug":"Quick系列项目","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/"},{"name":"QuickSpi","slug":"Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/Quick系列项目/QuickSpi/"}]}]